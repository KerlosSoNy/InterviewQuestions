{
    "angular": [
        {
            "question": "What is Angular Framework?",
            "answer": "Angular is a TypeScript-based open-source front-end web application framework developed by Google. It is used to build dynamic single-page applications (SPAs) with features like dependency injection, two-way data binding, and modular architecture."
        },
        {
            "question": "What is TypeScript?",
            "answer": "TypeScript is a superset of JavaScript developed by Microsoft. It extends JavaScript by adding static types to improve developer productivity and maintainability. TypeScript compiles down to JavaScript, allowing it to run on any platform that supports JavaScript."
        },
        {
            "question": "Write a pictorial diagram of Angular architecture.",
            "answer": "Angular architecture consists of modules, components, templates, directives, services (with Dependency Injection), and routing. The architecture ensures efficient user input handling, data services, and view updates. (Diagram not included in the object but can be visualized.)"
        },
        {
            "question": "What are the key components of Angular?",
            "answer": "The key components of Angular are Modules, Components, Templates, Directives, Services (with Dependency Injection), and Routing."
        },
        {
            "question": "What are directives?",
            "answer": "Directives are classes in Angular that enhance the functionality of DOM elements. Types include Structural Directives (e.g., *ngIf, *ngFor), Attribute Directives (e.g., ngClass, ngStyle), and Custom Directives."
        },
        {
            "question": "What are components?",
            "answer": "Components are the building blocks of Angular applications, consisting of a template (HTML), class (TypeScript logic), styles (CSS), and a selector (custom HTML tag)."
        },
        {
            "question": "What is a template?",
            "answer": "A template is an HTML structure in Angular, enhanced with Angular directives, bindings, and expressions. It represents the view for a component and interacts with the component class."
        },
        {
            "question": "What is a module?",
            "answer": "A module is a logical container in Angular that organizes components, directives, pipes, and services. It is defined using the @NgModule decorator, with the root module being AppModule."
        },
        {
            "question": "What are lifecycle hooks available?",
            "answer": "Angular lifecycle hooks allow components to tap into specific stages of their creation and destruction. Examples include ngOnInit, ngOnChanges, ngDoCheck, ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, and ngOnDestroy."
        },
        {
            "question": "What is data binding?",
            "answer": "Data binding connects the component's data to the template. Types include Interpolation ({{expression}}), Property Binding ([property]=\"value\"), Event Binding ((event)=\"handler\"), and Two-way Binding ([(ngModel)]=\"property\")."
        },
        {
            "question": "What is metadata?",
            "answer": "Metadata provides additional information about a class or component to Angular, defined using decorators like @Component and @NgModule."
        },
        {
            "question": "What is Angular CLI?",
            "answer": "Angular CLI (Command Line Interface) is a tool to initialize, develop, scaffold, and maintain Angular projects. It simplifies tasks like creating components, services, routing modules, and building production-ready apps."
        },
        {
            "question": "What is Angular Framework?",
            "answer": "Angular is a TypeScript-based open-source front-end web application framework developed by Google. It is used to build dynamic single-page applications (SPAs) with features like dependency injection, two-way data binding, and modular architecture."
        },
        {
            "question": "What is TypeScript?",
            "answer": "TypeScript is a superset of JavaScript developed by Microsoft. It extends JavaScript by adding static types to improve developer productivity and maintainability. TypeScript compiles down to JavaScript, allowing it to run on any platform that supports JavaScript."
        },
        {
            "question": "Write a pictorial diagram of Angular architecture.",
            "answer": "Angular architecture consists of modules, components, templates, directives, services (with Dependency Injection), and routing. The architecture ensures efficient user input handling, data services, and view updates. (Diagram not included in the object but can be visualized.)"
        },
        {
            "question": "What are the key components of Angular?",
            "answer": "The key components of Angular are Modules, Components, Templates, Directives, Services (with Dependency Injection), and Routing."
        },
        {
            "question": "What are directives?",
            "answer": "Directives are classes in Angular that enhance the functionality of DOM elements. Types include Structural Directives (e.g., *ngIf, *ngFor), Attribute Directives (e.g., ngClass, ngStyle), and Custom Directives."
        },
        {
            "question": "What are components?",
            "answer": "Components are the building blocks of Angular applications, consisting of a template (HTML), class (TypeScript logic), styles (CSS), and a selector (custom HTML tag)."
        },
        {
            "question": "What is a template?",
            "answer": "A template is an HTML structure in Angular, enhanced with Angular directives, bindings, and expressions. It represents the view for a component and interacts with the component class."
        },
        {
            "question": "What is a module?",
            "answer": "A module is a logical container in Angular that organizes components, directives, pipes, and services. It is defined using the @NgModule decorator, with the root module being AppModule."
        },
        {
            "question": "What are lifecycle hooks available?",
            "answer": "Angular lifecycle hooks allow components to tap into specific stages of their creation and destruction. Examples include ngOnInit, ngOnChanges, ngDoCheck, ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, and ngOnDestroy."
        },
        {
            "question": "What is data binding?",
            "answer": "Data binding connects the component's data to the template. Types include Interpolation ({{expression}}), Property Binding ([property]=\"value\"), Event Binding ((event)=\"handler\"), and Two-way Binding ([(ngModel)]=\"property\")."
        },
        {
            "question": "What is metadata?",
            "answer": "Metadata provides additional information about a class or component to Angular, defined using decorators like @Component and @NgModule."
        },
        {
            "question": "What is Angular CLI?",
            "answer": "Angular CLI (Command Line Interface) is a tool to initialize, develop, scaffold, and maintain Angular projects. It simplifies tasks like creating components, services, routing modules, and building production-ready apps."
        },
        {
            "question": "What is the difference between constructor and ngOnInit?",
            "answer": "The constructor is a TypeScript feature used for initializing class members, whereas ngOnInit is a lifecycle hook specifically designed for Angular components to handle initialization logic once the component is created."
        },
        {
            "question": "What is a service?",
            "answer": "A service is a class in Angular used to encapsulate business logic, data, or reusable functionalities. Services are typically injected into components or other services using Dependency Injection."
        },
        {
            "question": "What is dependency injection in Angular?",
            "answer": "Dependency Injection (DI) is a design pattern used in Angular to provide objects (dependencies) to a class through the constructor. It ensures decoupling and reusability of components and services."
        },
        {
            "question": "What is the purpose of async pipe?",
            "answer": "The async pipe automatically subscribes to an observable or promise and updates the template whenever the value changes, simplifying reactive programming."
        },
        {
            "question": "What is the purpose of *ngFor directive?",
            "answer": "The *ngFor directive is used to loop through arrays and display a list of elements dynamically in the template."
        },
        {
            "question": "What are pipes?",
            "answer": "Pipes in Angular are used to transform data within templates. For example, they can format dates, numbers, or strings."
        },
        {
            "question": "What is a parameterized pipe?",
            "answer": "A parameterized pipe allows passing arguments to modify the output. For example, `{{ value | date:'shortDate' }}` formats a date with a specific pattern."
        },
        {
            "question": "How do you chain pipes?",
            "answer": "Pipes can be chained by using multiple pipe operators (|). For example: `{{ value | currency | uppercase }}`."
        },
        {
            "question": "What is a custom pipe?",
            "answer": "A custom pipe is a user-defined pipe that allows developers to create their own transformation logic for specific requirements."
        },
        {
            "question": "What is the difference between pure and impure pipe?",
            "answer": "Pure pipes process data without modifying the original input and are executed only when their input changes, while impure pipes run on every change detection cycle."
        },
        {
            "question": "What is HttpClient and its benefits?",
            "answer": "HttpClient is a service in Angular that allows communication with backend APIs via HTTP. Benefits include simplified HTTP requests, built-in observables, and automatic JSON conversion."
        },
        {
            "question": "What are dynamic components?",
            "answer": "Dynamic components are components that are created and inserted into the DOM at runtime rather than being declared in a template."
        },
        {
            "question": "What are router events?",
            "answer": "Router events are a series of events triggered during the routing process in Angular, such as navigation start, end, and error."
        },
        {
            "question": "What is activated route?",
            "answer": "ActivatedRoute is a service in Angular that provides access to route parameters, data, and query parameters associated with the current route."
        },
        {
            "question": "How do you define routes?",
            "answer": "Routes are defined using the RouterModule and an array of route objects, each specifying a path and the component to load. Example: `{ path: 'home', component: HomeComponent }`."
        },
        {
            "question": "What is the purpose of Wildcard route?",
            "answer": "A Wildcard route is used to handle undefined paths and typically redirects users to a 'Not Found' or similar page."
        },
        {
            "question": "What is Angular Universal?",
            "answer": "Angular Universal is a framework for server-side rendering (SSR) of Angular applications, improving SEO and initial load performance."
        },
        {
            "question": "What is ng-content?",
            "answer": "ng-content is a directive that enables content projection, allowing you to insert dynamic content into a component's template."
        },
        {
            "question": "What is Angular Input and Output and EventEmitter?",
            "answer": "Input and Output are decorators in Angular used for parent-child communication. EventEmitter is used with the Output decorator to emit events from the child to the parent."
        },
        {
            "question": "What is Template Reference Variable in Angular?",
            "answer": "A Template Reference Variable is a variable declared in a template using the # symbol. It provides access to a DOM element or Angular component instance."
        },
        {
            "question": "What is ng-container in Angular?",
            "answer": "ng-container is an Angular element that acts as a logical container without rendering any additional DOM."
        },
        {
            "question": "How to use ng-template and TemplateRef in Angular?",
            "answer": "ng-template is a directive for defining a reusable template. TemplateRef represents the template and can be used for dynamic rendering."
        },
        {
            "question": "How to Use ngTemplateOutlet in Angular?",
            "answer": "The ngTemplateOutlet directive is used to dynamically insert a template into a view using the [ngTemplateOutlet] binding."
        },
        {
            "question": "What are Signals?",
            "answer": "Signals in Angular represent reactive state management, providing a way to track and react to changes in data."
        },
        {
            "question": "Why Signal?",
            "answer": "Signals improve reactivity and state tracking in Angular applications, offering better integration with change detection."
        },
        {
            "question": "Angular Signals and Observables: How and When to Use Each?",
            "answer": "Signals are ideal for local state management, while Observables are better for asynchronous operations like API calls or streams."
        },
        {
            "question": "What is Effect in Signal?",
            "answer": "Effect in Signal is a mechanism to react to changes in Signals. Effects listen to signal changes and trigger side-effects, like updating the DOM or performing API calls, without altering the Signal's state."
        },
        {
            "question": "What is ElementRef in Angular?",
            "answer": "ElementRef is a wrapper around a native DOM element in Angular. It is used to directly interact with the DOM element, but its usage is discouraged for security reasons in favor of Renderer2."
        },
        {
            "question": "What is Renderer2?",
            "answer": "Renderer2 is a service in Angular that provides an API for safely manipulating the DOM, such as creating elements, adding classes, and handling events."
        },
        {
            "question": "How to Use @ViewChild and @ViewChildren?",
            "answer": "@ViewChild is used to get a reference to a single DOM element or directive in a component's template. @ViewChildren is used to get references to multiple elements or directives."
        },
        {
            "question": "What are ContentChild and ContentChildren in Angular?",
            "answer": "ContentChild and ContentChildren are decorators used to access projected content inside a component using queries. ContentChild gets a single element, while ContentChildren retrieves multiple elements."
        },
        {
            "question": "What are decorators in Angular?",
            "answer": "Decorators in Angular are functions that add metadata to classes, methods, properties, or parameters. Examples include @Component, @NgModule, @Injectable, and @Directive."
        },
        {
            "question": "What are AfterViewInit, AfterViewChecked, AfterContentInit, and AfterContentChecked in Angular?",
            "answer": "These are lifecycle hooks in Angular: AfterViewInit is triggered after the view is initialized, AfterViewChecked is triggered after the view is checked for changes, AfterContentInit is triggered after projected content is initialized, and AfterContentChecked is triggered after the content is checked for changes."
        },
        {
            "question": "What is View Encapsulation in Angular?",
            "answer": "View Encapsulation determines how styles in a component are scoped. Angular supports three options: Emulated (default, scoped styles using attributes), None (global styles), and ShadowDom (uses native Shadow DOM for isolation)."
        },
        {
            "question": "What are Host and hostContext in Angular?",
            "answer": "The 'Host' selector applies styles to the host element of a component, while 'hostContext' applies styles based on a parent class or context."
        },
        {
            "question": "How does Angular Change Detection really work?",
            "answer": "Angular's change detection checks for changes in data-bound properties and updates the DOM accordingly. It uses a tree of views and runs in the Angular Zone to capture asynchronous operations."
        },
        {
            "question": "What is the relationship between Change Detection, Zone.js, Zoneless mode, Local Change Detection, and Signals?",
            "answer": "Zone.js provides automatic tracking of asynchronous operations for change detection. Zoneless mode skips Zone.js, requiring manual triggering of change detection. Signals offer reactive state management, complementing or replacing traditional change detection."
        },
        {
            "question": "What is Angular Signals Component API input, output, and model?",
            "answer": "Angular's Signals Component API allows managing component inputs, outputs, and models reactively. Inputs and outputs are handled as Signals, enabling more efficient change detection and communication."
        },
        {
            "question": "What is Resource API?",
            "answer": "The Resource API in Angular provides a structured way to interact with RESTful APIs, managing CRUD operations and handling HTTP requests and responses."
        },
        {
            "question": "What is an Angular Service?",
            "answer": "An Angular Service is a singleton class used to share data, logic, or functionalities across different components of an Angular application. It is typically used to encapsulate business logic or reusable code."
        },
        {
            "question": "What are Angular Services used for?",
            "answer": "Angular Services are used for tasks such as fetching data from APIs, sharing data between components, encapsulating business logic, managing state, and implementing reusable functionalities."
        },
        {
            "question": "What are the advantages of Angular Service?",
            "answer": "Advantages include: (1) Code reusability by encapsulating logic in a single place, (2) Easy sharing of data across components, (3) Separation of concerns, (4) Improved testability, and (5) Simplified dependency injection."
        },
        {
            "question": "What are the benefits of Dependency Injection?",
            "answer": "Dependency Injection provides (1) Decoupled code for better modularity, (2) Enhanced testability by mocking dependencies, (3) Improved maintainability by centralizing dependency creation, and (4) Cleaner code by managing object lifetimes and resolving dependencies automatically."
        },
        {
            "question": "What are the five main players in the Angular Dependency Injection Framework?",
            "answer": "The five main players are: (1) Service: The class containing shared logic, (2) Component: The consumer of the service, (3) Injector: The system that provides the service instance, (4) Provider: The configuration specifying how to create or locate a dependency, and (5) Dependency: The required instance or class being injected."
        },
        {
            "question": "What is Service Scope in Angular?",
            "answer": "Service scope refers to the lifecycle and availability of a service. A service can be scoped to: (1) Application-wide using the `providedIn: 'root'` metadata, (2) Feature modules by adding it to a module's providers array, or (3) Component-specific by declaring it in a component's providers array."
        },
        {
            "question": "What is Angular Injector?",
            "answer": "The Angular Injector is a service responsible for instantiating and providing dependencies to classes like components and services. It resolves dependencies declared in constructors and ensures proper service instantiation."
        },
        {
            "question": "When is Angular Injector created?",
            "answer": "The Angular Injector is created during the application's initialization process, specifically when the Angular runtime compiles and bootstraps the root module."
        },
        {
            "question": "How do you register a service with an injector?",
            "answer": "A service is registered with an injector using providers. This can be done in multiple ways: (1) Using `providedIn` metadata in the service's @Injectable decorator, (2) Adding the service to a module's `providers` array, or (3) Adding the service to a component's `providers` array for component-level injection."
        },
        {
            "question": "What are Angular Providers?",
            "answer": "Angular Providers are objects used to configure the DI system. They specify how to create or retrieve a dependency. Common types include: (1) Class Providers (default), (2) Value Providers, (3) Factory Providers, and (4) Aliased Providers."
        },
        {
            "question": "What are the types of Providers in Angular?",
            "answer": "The main types of providers in Angular are: (1) **Class Providers**: The default type using a class as the provider, (2) **Value Providers**: Provides a fixed value, (3) **Factory Providers**: Uses a factory function to create a dependency, (4) **Existing Providers**: Alias another provider, and (5) **Multi Providers**: Allows multiple values for a single token."
        },
        {
            "question": "How does Dependency Injection and Resolution work in Angular?",
            "answer": "In Angular, Dependency Injection (DI) resolves dependencies by: (1) An injector checking for the dependency in its own scope, (2) If not found, the injector traverses up the injector hierarchy, (3) If the dependency is not found in any injector, an error is thrown. Angular uses a tree of injectors, with the root injector at the application level and child injectors at module, component, or directive levels."
        },
        {
            "question": "What is the Element Injector Tree in Angular?",
            "answer": "The Element Injector Tree is a hierarchy of injectors attached to Angular's component and directive tree. Each component has its own injector, which allows for scoped resolution of dependencies. The tree structure ensures that child injectors can override dependencies provided by parent injectors."
        },
        {
            "question": "What does `providedIn` root, any, and platform mean in Angular?",
            "answer": "The `providedIn` metadata determines where a service is provided: (1) **root**: The service is provided at the root injector and shared across the application, (2) **any**: A new instance of the service is created for each module or lazy-loaded module, and (3) **platform**: The service is provided in a special platform-level injector, shared across multiple Angular applications."
        },
        {
            "question": "What are @Self, @SkipSelf, and @Optional decorators in Angular?",
            "answer": "These decorators modify how dependencies are resolved: (1) **@Self**: Forces Angular to look for the dependency only in the current injector, (2) **@SkipSelf**: Forces Angular to skip the current injector and look for the dependency in parent injectors, (3) **@Optional**: Allows the dependency to be null if it is not found in the injector hierarchy."
        },
        {
            "question": "Explain RxJS Observable?",
            "answer": "An RxJS Observable is a stream of data that can emit values over time. Observables are lazy, meaning they don't execute until subscribed to, and they support asynchronous operations like events, HTTP calls, or timer-based operations."
        },
        {
            "question": "What are RxJS operators?",
            "answer": "RxJS operators are pure functions used to manipulate or transform data streams emitted by Observables. Examples include map, filter, mergeMap, and catchError."
        },
        {
            "question": "What is Observable.pipe() and how to use it?",
            "answer": "The `pipe()` method is used to compose and chain multiple RxJS operators. For example: `observable.pipe(map(x => x * 2), filter(x => x > 10))` applies the operators sequentially to transform the data."
        },
        {
            "question": "What is the difference between RxJS of and from?",
            "answer": "`of` creates an Observable from a set of values, whereas `from` creates an Observable from an array, promise, or iterable. Example: `of(1, 2, 3)` vs. `from([1, 2, 3])`."
        },
        {
            "question": "Explain RxJS map operator?",
            "answer": "The `map` operator transforms each emitted value by applying a function to it. For example: `source.pipe(map(x => x * 2))` doubles each emitted value."
        },
        {
            "question": "Explain RxJS switchMap operator?",
            "answer": "`switchMap` maps each value to a new Observable and unsubscribes from the previous Observable when a new value is emitted. It is commonly used for canceling HTTP requests."
        },
        {
            "question": "Explain RxJS mergeMap operator?",
            "answer": "`mergeMap` maps each emitted value to a new Observable and subscribes to all inner Observables simultaneously. It is useful for parallel operations."
        },
        {
            "question": "Explain RxJS concatMap operator?",
            "answer": "`concatMap` maps each emitted value to a new Observable but subscribes to them sequentially, waiting for the previous Observable to complete before moving to the next."
        },
        {
            "question": "Explain RxJS exhaustMap operator?",
            "answer": "`exhaustMap` maps each value to a new Observable but ignores any subsequent values until the current inner Observable completes. It is useful for handling long-running tasks."
        },
        {
            "question": "How will you handle errors on Observable using RxJS throwError?",
            "answer": "`throwError` is used to create an Observable that emits an error. It can be used in conjunction with `catchError` to handle errors."
        },
        {
            "question": "How will you handle errors on Observable using RxJS catchError?",
            "answer": "`catchError` is an operator that intercepts errors and allows you to handle them or return a new Observable. For example: `source.pipe(catchError(error => of('Fallback value')))`."
        },
        {
            "question": "Explain RxJS retry operator?",
            "answer": "`retry` resubscribes to the source Observable in case of an error, retrying a specified number of times. Example: `source.pipe(retry(3))` retries the Observable three times on error."
        },
        {
            "question": "Explain RxJS filter operator?",
            "answer": "The `filter` operator allows you to emit only the values that satisfy a given predicate. Example: `source.pipe(filter(x => x > 5))` emits values greater than 5."
        },
        {
            "question": "Explain RxJS tap operator?",
            "answer": "`tap` allows you to perform side effects, such as logging or debugging, without altering the data stream. Example: `source.pipe(tap(value => console.log(value)))`."
        },
        {
            "question": "Explain RxJS takeUntil operator?",
            "answer": "`takeUntil` emits values from the source Observable until another Observable emits a value, at which point it completes. It is commonly used to manage subscriptions."
        },
        {
            "question": "Explain RxJS debounceTime operator?",
            "answer": "`debounceTime` delays the emitted values by a specified time. If a new value is emitted within the time frame, the timer resets. It is useful for handling user input events like search."
        },
        {
            "question": "Explain RxJS combineLatestWith operator?",
            "answer": "`combineLatestWith` combines the latest values from multiple Observables whenever one emits. Example: `obs1.pipe(combineLatestWith(obs2))` emits tuples of the latest values."
        },
        {
            "question": "Explain RxJS fromEvent operator?",
            "answer": "`fromEvent` creates an Observable from DOM events. Example: `fromEvent(document, 'click')` emits click events from the document."
        },
        {
            "question": "What is the difference between Subject, BehaviorSubject, ReplaySubject, and AsyncSubject in RxJS?",
            "answer": "Subjects emit values to multiple subscribers: (1) **Subject**: Emits only to subscribers at the time of emission, (2) **BehaviorSubject**: Emits the latest value to new subscribers, (3) **ReplaySubject**: Emits all previous values to new subscribers, (4) **AsyncSubject**: Emits the last value to subscribers only when the source Observable completes."
        },
        {
            "question": "What are the best practices for managing Observable subscriptions in Angular and ensuring there are no memory leaks?",
            "answer": "Best practices include: (1) Unsubscribe manually in `ngOnDestroy`, (2) Use `async` pipes for auto-unsubscription, (3) Use `takeUntil` with a destroy signal, and (4) Use RxJS operators like `shareReplay` to manage shared subscriptions."
        },
        {
            "question": "What are the differences between cold Observable and hot Observable?",
            "answer": "Cold Observables start emitting values only when subscribed to, while hot Observables emit values regardless of subscriptions. Example: HTTP requests are cold, and event streams are hot."
        },
        {
            "question": "What are the differences between Observables and Promises?",
            "answer": "Observables: (1) Lazy and can emit multiple values, (2) Can be canceled, (3) Support operators for transformations. Promises: (1) Eager and emit a single value, (2) Cannot be canceled, (3) No operator support."
        },
        {
            "question": "What is a higher-order Observable?",
            "answer": "A higher-order Observable is an Observable that emits other Observables. Operators like `mergeAll` or `switchAll` are used to flatten and subscribe to these inner Observables."
        },
        {
            "question": "How can you share a single Observable among multiple subscribers?",
            "answer": "You can share a single Observable using operators like `share`, `shareReplay`, or `publish`. These operators ensure that the Observable executes only once and shares the results with all subscribers."
        },
        {
            "question": "Describe the types of forms created in Angular application?",
            "answer": "In Angular, there are two types of forms: (1) **Reactive Forms**: These are programmatically managed, more scalable, and flexible, where form control is created and handled explicitly in the component. (2) **Template-driven Forms**: These are simpler to use, where form control is defined in the HTML template, and Angular automatically binds the controls to the component."
        },
        {
            "question": "How will you create a reactive form in Angular?",
            "answer": "To create a reactive form in Angular, you need to import `ReactiveFormsModule` from `@angular/forms` in your module. In the component, define a `FormGroup` and `FormControl` for each field, and use the `formGroup` directive in the template to bind it to the form."
        },
        {
            "question": "Explain FormControl?",
            "answer": "`FormControl` represents a single input element in a form and tracks its value and validation status. It is instantiated using `new FormControl(initialValue, validators)`. It can be used to track individual form controls like text inputs."
        },
        {
            "question": "Explain FormGroup?",
            "answer": "`FormGroup` is a collection of `FormControl` objects. It is used to group form controls together. It can be instantiated using `new FormGroup({ controlName: new FormControl() })`. `FormGroup` allows tracking the validity and status of multiple controls collectively."
        },
        {
            "question": "Explain FormArray?",
            "answer": "`FormArray` is used when you have an array of form controls. It is a collection of `FormControl` or `FormGroup` instances and can be dynamically manipulated (added, removed). It is instantiated using `new FormArray([controls])`."
        },
        {
            "question": "Explain FormBuilder?",
            "answer": "`FormBuilder` is a service that simplifies the creation of `FormGroup`, `FormControl`, and `FormArray` instances. It provides convenient methods like `group()`, `control()`, and `array()` for creating forms. It is typically used to streamline form creation in reactive forms."
        },
        {
            "question": "Explain FormRecord?",
            "answer": "`FormRecord` is a new type introduced in Angular 15 as a more flexible, strongly-typed alternative to `FormGroup`. It is an object that represents a group of form controls and their associated values, offering better type safety and structure."
        },
        {
            "question": "How will you use valueChanges?",
            "answer": "`valueChanges` is an Observable that emits the value of the form control whenever it changes. You can subscribe to it using `control.valueChanges.subscribe(value => { /* logic */ })` to react to changes in real time."
        },
        {
            "question": "How will you use statusChanges?",
            "answer": "`statusChanges` is an Observable that emits the status of a form control (valid, invalid, pending, or disabled) whenever it changes. You can subscribe to it using `control.statusChanges.subscribe(status => { /* logic */ })`."
        },
        {
            "question": "What is the difference between setValue() and patchValue()?",
            "answer": "`setValue()` requires all form controls to be updated and will throw an error if any control is missing. In contrast, `patchValue()` allows partial updates, only changing the specified controls in the form."
        },
        {
            "question": "How will you add and remove controls on FormGroup dynamically?",
            "answer": "To dynamically add or remove controls in a `FormGroup`, you can use the `addControl(name, control)` method to add a control, and `removeControl(name)` to remove a control."
        },
        {
            "question": "What is the difference between (ngModelChange) and (change)?",
            "answer": "`(ngModelChange)` is an Angular event that is emitted whenever the value of the bound model changes (used with `ngModel`). `(change)` is a native DOM event that is fired when an input field loses focus and its value has changed."
        },
        {
            "question": "How to add async validation in FormControl?",
            "answer": "To add async validation in `FormControl`, you can use the `asyncValidator` option when creating a `FormControl`. For example: `new FormControl('', [Validators.required], [this.asyncValidator()])` where `asyncValidator()` is a function returning an observable."
        },
        {
            "question": "How will you validate template-driven form?",
            "answer": "In template-driven forms, validation is performed using built-in directives like `required`, `minlength`, `maxlength`, etc., in the template. You can access the validation status using the `ngModel` directive (e.g., `#name='ngModel'`), and check the validity properties like `name.valid`."
        },
        {
            "question": "Uses of Angular Route Guards",
            "answer": "Angular Route Guards are used to control access to routes based on certain conditions. They are typically used to: (1) Prevent navigation to a route, (2) Protect routes requiring authentication, (3) Resolve data before navigating to a route, (4) Prevent navigation away from a route if unsaved changes exist, and (5) Lazy load routes based on certain conditions."
        },
        {
            "question": "Types of Route Guards",
            "answer": "There are five types of Route Guards in Angular: (1) **CanActivate**: Prevents or allows navigation to a route. (2) **CanActivateChild**: Prevents or allows navigation to child routes. (3) **CanDeactivate**: Prevents or allows navigation away from a route. (4) **Resolve**: Fetches data before a route is activated. (5) **CanLoad**: Prevents or allows lazy-loaded routes to be loaded."
        },
        {
            "question": "What is CanActivate Guard?",
            "answer": "The `CanActivate` guard is used to prevent or allow navigation to a route based on conditions like authentication or permissions. It is implemented as a service and used in the routing configuration to determine whether a route should be activated. For example: `canActivate: [AuthGuard]`."
        },
        {
            "question": "What is CanActivateChild Guard?",
            "answer": "The `CanActivateChild` guard is similar to `CanActivate`, but it specifically applies to child routes. It prevents or allows navigation to child routes of a parent route based on a condition. It can be used to apply the same restrictions across all child routes of a parent route."
        },
        {
            "question": "What is CanDeactivate Guard?",
            "answer": "The `CanDeactivate` guard is used to prevent or allow navigation away from the current route. This is typically used when the user has unsaved changes in a form or a component and tries to navigate away. The guard can ask for user confirmation before allowing navigation."
        },
        {
            "question": "How to Use Resolve Guard?",
            "answer": "The `Resolve` guard is used to fetch data before a route is activated. It ensures that all required data is fetched before the component is instantiated. It is defined in the routing configuration with a `resolve` property. For example: `resolve: { data: DataResolver }` where `DataResolver` fetches data before the route activates."
        },
        {
            "question": "How to Use CanLoad Guard?",
            "answer": "The `CanLoad` guard is used to prevent or allow lazy-loaded routes from being loaded. It is useful when you want to load a module only if certain conditions are met, like user authentication. It is applied to lazy-loaded routes in the routing configuration with `canLoad: [AuthGuard]`."
        },
        {
            "question": "Why Handle Errors?",
            "answer": "Handling errors is crucial in Angular applications to ensure a smooth user experience and prevent the app from crashing or behaving unpredictably. Proper error handling allows the application to react to failures (e.g., network issues, invalid responses) in a controlled way, providing feedback to the user and allowing the application to recover or retry the operation if necessary."
        },
        {
            "question": "What is HttpErrorResponse?",
            "answer": "`HttpErrorResponse` is an object that represents an error response from an HTTP request in Angular. It is part of the `@angular/common/http` module and contains details about the error, such as the status code, error message, and headers. This object is returned in case of an unsuccessful HTTP request, allowing developers to manage different error scenarios like 404 (Not Found), 500 (Server Error), and others."
        },
        {
            "question": "How Can Catching Errors in HTTP Request?",
            "answer": "In Angular, errors from HTTP requests can be caught using the `catchError` operator from RxJS. This operator can be used inside the `pipe()` method to handle errors and provide a fallback value or rethrow the error. For example: `httpClient.get(url).pipe(catchError(error => { return of('Error occurred') }))`. You can also catch errors globally using an HTTP interceptor."
        },
        {
            "question": "What is Angular Http Interceptor?",
            "answer": "An `HttpInterceptor` in Angular is a service that can intercept HTTP requests and responses before they are sent or received. It allows you to modify requests (e.g., adding authentication tokens) or responses (e.g., logging or handling errors). Interceptors are powerful for tasks like global error handling, setting HTTP headers, logging requests, and retrying failed requests. They are implemented by creating a service that implements `HttpInterceptor` interface and provided in the `HTTP_INTERCEPTORS` array."
        }
    ],
    "css": [
        {
            "question": "What is CSS?",
            "answer": "CSS (Cascading Style Sheets) is used to style and layout web pages. It controls the appearance of elements, such as their colors, sizes, and positions."
        },
        {
            "question": "What are the different ways to apply CSS to a webpage?",
            "answer": "CSS can be applied in three ways: 1) Inline CSS (using the style attribute in HTML elements), 2) Internal CSS (within the <style> tag in the HTML document's <head>), and 3) External CSS (linked using the <link> tag to a separate CSS file)."
        },
        {
            "question": "What is the difference between 'class' and 'id' selectors in CSS?",
            "answer": "'class' selectors are used to target multiple elements and can be reused across different elements, while 'id' selectors are used to target a single, unique element on a page."
        },
        {
            "question": "What are the CSS box model properties?",
            "answer": "The CSS box model consists of the content area, padding, border, and margin. These properties define the space around elements and how they are displayed on the page."
        },
        {
            "question": "What is the 'z-index' in CSS?",
            "answer": "'z-index' is a CSS property used to control the stacking order of elements. Elements with a higher z-index value will appear on top of those with a lower z-index value, but it only works on positioned elements (those with position: relative, absolute, or fixed)."
        },
        {
            "question": "Explain the difference between 'position: absolute', 'position: relative', and 'position: fixed'.",
            "answer": "'position: absolute' positions an element relative to its closest positioned ancestor, 'position: relative' positions an element relative to its normal position, and 'position: fixed' positions an element relative to the browser window, staying fixed in place even when the page is scrolled."
        },
        {
            "question": "What is the 'display' property in CSS?",
            "answer": "The 'display' property defines the display behavior of an element. Common values include 'block' (elements take up the full width of the container), 'inline' (elements only take up as much width as their content), and 'none' (element is not displayed)."
        },
        {
            "question": "What is the difference between 'display: none' and 'visibility: hidden'?",
            "answer": "'display: none' removes the element from the layout entirely, while 'visibility: hidden' hides the element but still occupies space in the layout."
        },
        {
            "question": "What are pseudo-elements and pseudo-classes??",
            "answer": "Pseudo-classes are used to style elements based on their state or position in the document, such as ':hover' for when an element is hovered over, ':first-child' for the first child of a parent element, or ':nth-child()' to target specific children. Pseudo-elements are used to style specific parts of an element, such as ':before' to insert content before an element, ':after' to insert content after an element, or ':first-letter' to style the first letter of a text block."
        },
        {
            "question": "What is the 'nth-child' selector in CSS?",
            "answer": "The ':nth-child()' selector is used to target specific child elements of a parent based on a pattern, such as even, odd, or a specific number. Example: 'li:nth-child(2)' targets the second list item in an unordered list."
        },
        {
            "question": "What is the difference between nth-child() and nth-of-type()?",
            "answer": "nth-child(): Matches the child based on its position relative to all siblings. nth-of-type(): Matches the child based on its position relative to siblings of the same type."
        },
        {
            "question": "What is Flexbox in CSS?",
            "answer": "Flexbox is a layout model that allows easy alignment and distribution of elements within a container, even when their sizes are unknown or dynamic. It provides properties like 'justify-content', 'align-items', and 'flex-direction' to manage the positioning of items within a flex container."
        },
        {
            "question": "How does Flexbox work?",
            "answer": "Flexbox (Flexible Box Layout) is a CSS layout model designed to align and distribute space among items in a container, even when their sizes are dynamic. It uses a parent container with `display: flex;` and aligns items along two axes: the main axis (defined by `flex-direction`) and the cross axis (perpendicular to the main axis). Key properties include `justify-content` for alignment along the main axis, `align-items` for alignment along the cross axis, and `flex-wrap` to handle wrapping of items. Flexbox simplifies responsive design by adjusting item sizes and spacing automatically."
        },
        {
            "question": "What is the 'float' property in CSS?",
            "answer": "The 'float' property is used to float an element to the left or right of its container, allowing other content to wrap around it. However, it has been largely replaced by Flexbox and Grid layouts in modern web design."
        },
        {
            "question": "What is a CSS Grid?",
            "answer": "CSS Grid is a two-dimensional layout system that allows web designers to create complex layouts with rows and columns. It is more powerful and flexible than Flexbox when dealing with grid-based designs."
        },
        {
            "question": "How does CSS Grid differ from Flexbox?",
            "answer": "CSS Grid is a two-dimensional layout system, meaning it can handle both rows and columns, while Flexbox is a one-dimensional layout system, focusing on either rows or columns at a time. CSS Grid is best for designing complete page layouts, whereas Flexbox is ideal for aligning and distributing items in a single axis. For example, CSS Grid allows you to define a grid structure with rows and columns using properties like `grid-template-rows` and `grid-template-columns`, while Flexbox aligns items along a single main axis using properties like `justify-content` and `align-items`."
        },
        {
            "question": "Explain the use of the grid-template-columns property.",
            "answer": "The `grid-template-columns` property defines the number and size of columns in a CSS Grid container. It accepts values such as fixed sizes (e.g., `100px`), relative sizes (e.g., `1fr` for fractional units), or a combination. For example, `grid-template-columns: 100px 1fr 2fr;` creates a grid with three columns: the first is 100px wide, the second takes up 1 fraction of the remaining space, and the third takes up 2 fractions of the remaining space."
        },
        {
            "question": "What are media queries in CSS?",
            "answer": "Media queries are used to apply different styles based on the device's characteristics, like screen size or resolution. They enable responsive design, ensuring that a webpage looks good on all devices."
        },
        {
            "question": "What is the 'transition' property in CSS?",
            "answer": "The 'transition' property allows you to change property values smoothly over a specified duration, enabling animations on hover or when certain conditions are met. It requires a target property, duration, and optional timing functions."
        },
        {
            "question": "What is the 'box-sizing' property?",
            "answer": "The 'box-sizing' property controls how the width and height of an element are calculated. 'content-box' (default) excludes padding and border from width/height, while 'border-box' includes padding and border in the element's total width and height."
        },
        {
            "question": "How do you center a block element in CSS?",
            "answer": "To center a block element horizontally, use 'margin: 0 auto'. To center it vertically, use 'display: flex' with 'align-items: center' and 'justify-content: center' on the parent container."
        },
        {
            "question": "What is the 'align-items' property in CSS?",
            "answer": "The 'align-items' property is used in Flexbox and Grid layouts to align items along the cross axis (vertical by default). Common values include 'flex-start', 'center', 'flex-end', 'stretch', and 'baseline'."
        },
        {
            "question": "What is the 'justify-content' property in CSS?",
            "answer": "The 'justify-content' property is used in Flexbox and Grid layouts to align and distribute items along the main axis (horizontal by default). Common values include 'flex-start' (align items at the start), 'center' (center items), 'space-between' (distribute items with space between), and 'space-around' (distribute items with space around)."
        },
        {
            "question": "How do you center an element horizontally and vertically using CSS?",
            "answer": "To center an element horizontally and vertically, you can use Flexbox by setting the parent container to 'display: flex', 'justify-content: center' (horizontal) and 'align-items: center' (vertical). Alternatively, use Grid with 'display: grid', 'place-items: center'."
        },
        {
            "question": "What is the 'opacity' property in CSS?",
            "answer": "The 'opacity' property in CSS is used to control the transparency level of an element, where '1' is fully opaque and '0' is fully transparent."
        },
        {
            "question": "What is the 'white-space' property in CSS?",
            "answer": "The 'white-space' property controls how whitespace is handled within an element. Common values are 'normal' (default behavior, collapsing whitespace), 'nowrap' (prevents line breaks), 'pre' (preserves whitespace and line breaks), and 'pre-wrap' (preserves whitespace but allows wrapping)."
        },
        {
            "question": "What is the 'cursor' property in CSS?",
            "answer": "The 'cursor' property is used to specify the type of cursor to be displayed when the mouse pointer is over an element. Common values include 'pointer' (hand cursor), 'default' (arrow), and 'text' (text selection)."
        },
        {
            "question": "What is the 'background' shorthand property in CSS?",
            "answer": "The 'background' shorthand property combines several background-related properties, such as 'background-color', 'background-image', 'background-position', 'background-size', and 'background-repeat', into one line."
        },
        {
            "question": "What is the 'text-transform' property in CSS?",
            "answer": "The 'text-transform' property is used to control the capitalization of text. Common values include 'uppercase' (converts text to uppercase), 'lowercase' (converts text to lowercase), and 'capitalize' (capitalizes the first letter of each word)."
        },
        {
            "question": "What is the difference between 'inline' and 'inline-block' elements?",
            "answer": "'inline' elements do not break the flow of content and only take up as much width as necessary, while 'inline-block' elements behave like inline elements but can have width and height properties."
        },
        {
            "question": "What is the purpose of the 'clearfix' hack?",
            "answer": "The 'clearfix' hack is used to clear floated elements within a container, preventing the container from collapsing. It typically involves adding the 'clearfix' class with 'clear: both' to the container."
        },
        {
            "question": "What is the 'clear' property in CSS?",
            "answer": "The 'clear' property is used to control the behavior of an element when it comes after floated elements. It can have values like 'left', 'right', or 'both' to prevent elements from wrapping around floats."
        },
        {
            "question": "What are the CSS 'transform' and 'translate' properties?",
            "answer": "The 'transform' property allows you to apply various transformations (such as scaling, rotating, or skewing) to an element. 'translate' is a transformation function that moves an element along the X, Y, or Z axis."
        },
        {
            "question": "What are CSS animations?",
            "answer": "CSS animations allow you to animate changes in CSS properties over time. They use '@keyframes' to define the states of an animation, and the 'animation' property to control its behavior, such as duration, delay, and iteration."
        },
        {
            "question": "What is the 'visibility' property in CSS?",
            "answer": "The 'visibility' property controls whether an element is visible or hidden. If set to 'hidden', the element will not be visible, but it will still occupy space in the layout. 'visible' is the default value, making the element visible."
        },
        {
            "question": "What is the purpose of the 'position' property in CSS?",
            "answer": "The 'position' property defines how an element is positioned in the document. Values include 'static' (default), 'relative', 'absolute', 'fixed', and 'sticky', each with different behavior regarding positioning in the layout."
        },
        {
            "question": "What is a 'sticky' positioning in CSS?",
            "answer": "'sticky' positioning allows an element to stick to the top or bottom of the viewport when scrolling, but it remains in the normal document flow until it reaches its defined position. Example: 'position: sticky; top: 0;'."
        },
        {
            "question": "What is the 'box-shadow' property in CSS?",
            "answer": "The 'box-shadow' property adds shadow effects to elements. It can take values for horizontal and vertical offsets, blur radius, spread radius, and color. Example: 'box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);'."
        },
        {
            "question": "What is the 'text-align' property in CSS?",
            "answer": "The 'text-align' property is used to set the horizontal alignment of text or inline elements within a block element. Common values include 'left', 'right', 'center', and 'justify'."
        },
        {
            "question": "How do you create a responsive layout with CSS?",
            "answer": "A responsive layout can be created using media queries, Flexbox, or CSS Grid. Media queries allow the layout to adjust based on the screen size, while Flexbox and Grid offer flexible methods to position elements dynamically."
        },
        {
            "question": "What is the 'overflow' property in CSS?",
            "answer": "The 'overflow' property controls what happens when content overflows the boundaries of a container. Common values are 'visible', 'hidden', 'scroll', and 'auto'."
        },
        {
            "question": "What are 'CSS variables'?",
            "answer": "CSS variables, also known as custom properties, are user-defined values that can be reused throughout a stylesheet. They are declared with '--' and accessed using 'var()'. Example: '--main-color: red;'."
        },
        {
            "question": "How do you add a gradient background in CSS?",
            "answer": "A gradient background can be added using the 'background-image' property with the 'linear-gradient' or 'radial-gradient' function. Example: 'background-image: linear-gradient(to right, red, blue);'."
        },
        {
            "question": "What is the 'max-width' property in CSS?",
            "answer": "The 'max-width' property defines the maximum width of an element. The element will not exceed this width, but can shrink down depending on its content or container's size."
        },
        {
            "question": "How can you make a website mobile-friendly with CSS?",
            "answer": "A mobile-friendly website can be made by using responsive design principles, such as using flexible layouts (via Flexbox or Grid), setting a fluid viewport using the 'meta' tag, and employing media queries to adapt to different screen sizes."
        },
        {
            "question": "What is the 'border-radius' property in CSS?",
            "answer": "The 'border-radius' property is used to create rounded corners on elements. It accepts one or more values for radius, such as 'border-radius: 10px;' for uniform rounding on all corners."
        },
        {
            "question": "What is the 'clip-path' property in CSS?",
            "answer": "The 'clip-path' property allows you to define a visible region of an element, making parts of it invisible. It can use various shapes like circles, polygons, or SVG paths. Example: 'clip-path: circle(50% at 50% 50%);'."
        },
        {
            "question": "What is the 'rem' unit in CSS?",
            "answer": "'rem' stands for 'root em'. It is relative to the root element's font size (typically 16px). For example, '1rem' equals the font size of the <html> element, making it easier to scale elements consistently."
        },
        {
            "question": "What is the difference between em and rem units in CSS?",
            "answer": "The `em` unit is relative to the font size of its parent element, meaning it compounds if used in nested elements. The `rem` unit is relative to the root element's font size (`html`), ensuring consistent sizing regardless of nesting. For example, if the root font size is 16px, `2rem` equals 32px everywhere, while `2em` depends on the parent element's font size."
        },
        {
            "question": "What is the 'vw' and 'vh' units in CSS?",
            "answer": "'vw' stands for viewport width, and 'vh' stands for viewport height. These units are relative to the viewport's dimensions. For example, '100vw' is equal to 100% of the viewport's width, and '100vh' is equal to 100% of the viewport's height."
        },
        {
            "question": "What is the 'will-change' property in CSS?",
            "answer": "The 'will-change' property is used to tell the browser which properties are likely to change, so it can optimize the performance of those elements. Example: 'will-change: transform;' prepares the element for upcoming transformations."
        },
        {
            "question": "How would you create a responsive design?",
            "answer": "Use: Fluid grids (e.g., flex, grid), Relative units (%, em, rem), Media queries."
        }
    ],
    "flutter": [
        {
            "question": "What is Flutter?",
            "answer": "Flutter is an open-source UI software development kit created by Google for building natively compiled applications for mobile, web, and desktop from a single codebase."
        },
        {
            "question": "What do you mean by Flutter SDK?",
            "answer": "The Flutter SDK (Software Development Kit) is a collection of tools, libraries, and frameworks required to develop Flutter applications. It includes the Flutter engine, Dart SDK, widgets, and other tools for building, testing, and compiling Flutter apps for mobile, web, and desktop platforms."
        },
        {
            "question": "Is Flutter Open Source or not?",
            "answer": "Yes, Flutter is an open-source framework developed by Google, and its source code is available on GitHub, allowing developers to contribute, modify, and use it freely for building cross-platform applications."
        },
        {
            "question": "How does Flutter differ from other cross-platform frameworks?",
            "answer": "Flutter differs from other cross-platform frameworks like React Native and Xamarin by using its own rendering engine (Skia) to draw widgets, ensuring high-performance rendering. It doesn't rely on native components but uses customizable widgets, unlike other frameworks that depend on platform-specific UI components."
        },
        {
            "question": "What do you mean by Dart?",
            "answer": "Dart is a programming language developed by Google, designed for building high-performance, scalable applications, particularly for mobile, web, and desktop environments."
        },
        {
            "question": "Write Dart's importance.",
            "answer": "Dart is important for its just-in-time (JIT) and ahead-of-time (AOT) compilation, offering high performance for both development (with hot reload) and production environments, making it ideal for building fast, cross-platform applications."
        },
        {
            "question": "How does Dart AOT work?",
            "answer": "Dart AOT (Ahead-of-Time) compilation is a process where Dart code is compiled into native machine code before it is run. This results in faster startup times and better performance because the code is already compiled to native code. In Flutter, AOT compilation is used when building release versions of apps to optimize performance."
        },
        {
            "question": "What is Fat Arrow Notation in Dart and when do you use it?",
            "answer": "Fat Arrow Notation (`=>`) in Dart is a shorthand syntax for writing single-expression functions or methods. It simplifies the code by eliminating the need for braces and the return keyword in functions that return a single expression. It's typically used for short functions or lambdas to make the code more concise."
        },
        {
            "question": "How is whenCompleted() different from then() in Flutter?",
            "answer": "`whenComplete()` is a method that executes a callback function when a `Future` completes, regardless of whether it completes successfully or with an error. It doesn't change the result of the `Future`. On the other hand, `then()` is used to handle the result of a `Future` when it completes successfully, and you can also handle errors using `catchError()`."
        },
        {
            "question": "What do you mean by Streams?",
            "answer": "In Dart, a Stream is a sequence of asynchronous events or data that can be handled in real-time. It allows handling data over time, such as user inputs or network responses, enabling developers to listen and respond to those events asynchronously."
        },
        {
            "question": "What are different types of Streams?",
            "answer": "There are two main types of Streams in Dart: **Single-Subscription Streams**, which can only be listened to once (e.g., file reads or HTTP responses), and **Broadcast Streams**, which allow multiple listeners to subscribe and receive events simultaneously (e.g., user input or system events)."
        },
        {
            "question": "Write the advantages of using Flutter.",
            "answer": "The advantages of using Flutter include a single codebase for both Android and iOS, fast development with hot reload, high-performance rendering with Skia, a rich set of customizable widgets, and seamless integration with native features for both mobile and web applications."
        },
        {
            "question": "Is Dart language necessary for Flutter?",
            "answer": "Yes, Dart is the primary programming language used for Flutter development. Flutter relies on Dart for building high-performance, cross-platform apps, and provides a rich set of libraries and tools tailored to work seamlessly with Dart."
        },
        {
            "question": "Why is Flutter preferred over other mobile app developing tools?",
            "answer": "Flutter is preferred for its fast development cycle with hot reload, a single codebase for both iOS and Android, high-performance rendering engine (Skia), a wide range of customizable widgets, and an active community, making it easier to build natively compiled apps quickly and efficiently."
        },
        {
            "question": "What was the first version of Flutter which ran on an Android operating system?",
            "answer": "The first version of Flutter that ran on an Android operating system was Flutter 1.0, released in December 2018. It marked the official stable release of Flutter for mobile development on both Android and iOS."
        },
        {
            "question": "Why does a flutter app usually take a long developing time?",
            "answer": "The first time you build a Flutter application, it takes much longer than usual since Flutter creates a device-specific IPA or APK file. Xcode and Gradle are used in this process to build a file, which usually takes a lot of time."
        },
        {
            "question": "List some important features of Flutter.",
            "answer": "Important features of Flutter include a hot reload for instant updates, a single codebase for cross-platform development, customizable widgets, high-performance rendering with Skia, and seamless integration with native features."
        },
        {
            "question": "Explain the concept of 'hot reload' in Flutter and how it aids in development.",
            "answer": "'Hot reload' in Flutter allows developers to quickly see changes made in the code without losing the current application state. This speeds up development by enabling real-time UI updates without needing to restart the app. Developers can adjust the code and immediately see the visual changes, which helps improve the efficiency of iterative development and debugging."
        },
        {
            "question": "What is hot restart in Flutter?",
            "answer": "Hot restart in Flutter resets the entire app and restarts it from the initial state, losing any current state or data. It rebuilds the widget tree and restarts the app's execution. It is typically used when you need to apply changes that require a full application restart, such as changes in global variables, app initialization code, or the app’s root structure."
        },
        {
            "question": "When would you use hot restart and when would you use hot reload in Flutter?",
            "answer": "Hot reload is used to quickly apply changes to the UI or small logic adjustments while preserving the app's state. It is ideal for quick iterative development of UI elements. Hot restart, on the other hand, is used when there are changes in the app's initialization, root structure, or global variables that cannot be handled by hot reload. Hot restart completely resets the app's state, making it necessary when a full restart is required to see the changes."
        },
        {
            "question": "What is the purpose of the BuildContext and why is it important in Flutter?",
            "answer": "The `BuildContext` is an object that represents the location of a widget in the widget tree. It is used to access information about the widget's environment, such as the parent widget, theme data, and other inherited properties. It is crucial because it allows widgets to communicate and interact with each other, making it a key part of widget management in Flutter."
        },
        {
            "question": "What do you understand about tween animation?",
            "answer": "Tween animation in Flutter refers to the process of smoothly transitioning between two values over time. It uses a Tween (a mathematical function) to interpolate between a start and an end value, typically controlling properties like position, size, opacity, or color, enabling smooth animations in the app."
        },
        {
            "question": "What is the difference between 'BuildContext' and 'Element' in Flutter?",
            "answer": "BuildContext is a handle to the location of a widget in the widget tree and provides access to the widget's parent tree and inherited widgets. On the other hand, an Element is an instantiation of a widget in the widget tree and represents a runtime representation of a widget. BuildContext is tied to the Element and is passed as a parameter to the widget's build method. Elements manage the lifecycle and updates of widgets, while BuildContext provides a way to access ancestor widgets or render objects."
        },
        {
            "question": "How does Flutter achieve high-performance UI rendering on various platforms?",
            "answer": "Flutter achieves high-performance UI rendering by using its own rendering engine called Skia. This engine directly draws the UI on the screen, bypassing the need for native components and platform-specific UI elements. Flutter’s declarative approach ensures minimal overhead and high rendering speed, even on low-resource devices. Additionally, Flutter provides optimized tools like widget caching and GPU acceleration, contributing to smooth performance across platforms."
        },
        {
            "question": "What is the 'widget tree' in Flutter and how does it contribute to building UIs?",
            "answer": "In Flutter, the 'widget tree' is a hierarchical structure of widgets that represents the UI of the application. Each widget in the tree describes part of the UI, and when the state of a widget changes, Flutter rebuilds only the affected parts of the tree. This efficient system allows Flutter to deliver performant and flexible UIs by abstracting the platform-specific rendering details and enabling rapid updates and dynamic UIs."
        },
        {
            "question": "How principles of object-oriented programming apply to Flutter?",
            "answer": "Flutter follows object-oriented programming (OOP) principles such as encapsulation, inheritance, polymorphism, and abstraction to build applications. Each widget in Flutter is an object that is derived from the `Widget` class, and developers can build custom widgets by extending existing ones. The widget tree structure represents a hierarchical relationship, and inheritance is used to extend the functionality of existing widgets. Encapsulation helps in organizing code by grouping stateful and stateless components. OOP principles allow for reusable, modular, and maintainable code."
        },
        {
            "question": "What is inheritance in Dart, and how is it used in Flutter widgets?",
            "answer": "Inheritance in Dart allows one class to inherit the properties and methods of another class. In Flutter, inheritance is used to extend and customize widgets by subclassing existing widgets. For example, developers can create custom widgets by extending classes like `StatelessWidget` or `StatefulWidget`. This allows for building more complex and reusable UI components. Flutter's widget hierarchy is built on inheritance, where custom widgets inherit behavior from base widget classes."
        },
        {
            "question": "How does encapsulation work in Dart, and why is it important in a Flutter project?",
            "answer": "Encapsulation in Dart involves bundling the data (variables) and methods (functions) that operate on the data into a single unit, i.e., a class. In Flutter, this helps in keeping widget states and behaviors contained within their respective widgets. Encapsulation ensures that widgets' internal implementation details are hidden from the outside world and only the necessary data is exposed, leading to better code organization, maintainability, and security."
        },
        {
            "question": "How do you cancel and clean up resources associated with streams in Flutter?",
            "answer": "To cancel and clean up resources associated with streams in Flutter, you can use the `StreamSubscription` class. After subscribing to a stream using `.listen()`, you can store the subscription and call its `cancel()` method when the stream is no longer needed. This is important to avoid memory leaks. Additionally, Flutter provides `StreamController`'s `close()` method to clean up when you're done with managing the stream."
        },
        {
            "question": "Explain the concept of 'Lazy Loading' and how it is implemented in Flutter.",
            "answer": "Lazy loading is a technique where resources or widgets are loaded only when needed, rather than at the initial app startup. In Flutter, lazy loading can be achieved by using widgets like `ListView.builder` or `GridView.builder`, which only create the widgets that are visible on screen. This reduces memory usage and improves performance by not rendering off-screen items. Lazy loading is especially useful when dealing with large data sets, infinite scrolling, or asynchronous data fetching. For example, loading images as the user scrolls or loading data only when a user reaches the bottom of a list."
        },
        {
            "question": "What is the role of `StreamController` in Dart, and how is it used to manage streams?",
            "answer": "`StreamController` is used in Dart to create and manage streams. It provides an interface for adding events to a stream and controlling its behavior. You can use `StreamController` to broadcast data asynchronously to multiple listeners. It offers two types: `Sink` for adding events to the stream and `Stream` for listening to those events. You can use it when you need fine-grained control over the stream, such as pausing, resuming, or closing the stream based on certain conditions. A common use case is managing real-time data or event-driven architectures."
        },
        {
            "question": "Explain the Flutter architecture.",
            "answer": "The Flutter architecture consists of three layers: the Framework (written in Dart, providing UI components and APIs), the Engine (handles rendering, animations, and platform-specific communication), and the Embedder (integrates the engine with platform-specific code on Android, iOS, or other platforms)."
        },
        {
            "question": "What is the significance of the `flutter_test` package, and how do you write unit tests for Flutter applications?",
            "answer": "`flutter_test` is a testing package in Flutter that provides the tools for writing unit tests, widget tests, and integration tests. Unit tests are used to test individual functions or methods, typically using the `test` function to validate that logic works correctly. Widget tests (or component tests) are used to test a widget’s behavior, UI, and interactions in isolation, often using `tester.pumpWidget()` to render a widget and simulate user interactions. You can also use mock data or mock dependencies to isolate specific logic from the rest of the app. The `flutter_test` package also integrates with test runners and other testing frameworks for full coverage."
        },
        {
            "question": "Explain the concept of the StreamBuilder widget in Flutter and when it is useful.",
            "answer": "The `StreamBuilder` widget in Flutter is used to build UI elements based on the latest snapshot of a stream. It listens to a stream and rebuilds the widget every time new data is emitted from the stream. This is useful for scenarios like displaying real-time updates (e.g., live data from a database or network request) where the UI needs to react to changing data dynamically."
        },
        {
            "question": "How can you implement Firebase authentication in a Flutter app?",
            "answer": "Firebase authentication can be implemented in Flutter using the `firebase_auth` package. You first need to configure Firebase in the app by following the setup steps provided in the Firebase console. Once set up, you can use methods like `signInWithEmailAndPassword`, `createUserWithEmailAndPassword`, or `signInWithGoogle` to handle user authentication. After successful authentication, you can access the authenticated user's data and manage their session with Firebase."
        },
        {
            "question": "Explain how Firestore is used for real-time data storage and synchronization in Flutter.",
            "answer": "Firestore is a flexible, scalable NoSQL cloud database provided by Firebase for storing and syncing data in real-time. In Flutter, Firestore can be integrated using the `cloud_firestore` package. It allows for reading and writing data to the cloud, as well as subscribing to real-time updates. Firestore can automatically sync changes to data across all clients, making it ideal for apps that require live data updates (e.g., chat apps, collaborative apps)."
        },
        {
            "question": "Describe the process of integrating Firebase Cloud Messaging (FCM) for push notifications.",
            "answer": "Firebase Cloud Messaging (FCM) can be integrated into a Flutter app using the `firebase_messaging` package. The process involves setting up Firebase in the Flutter project, configuring FCM in the Firebase console, and using the package to handle push notifications. Developers can listen for incoming messages with methods like `onMessage`, `onLaunch`, and `onResume`. Notifications can be sent directly from the Firebase console or through a server-side API."
        },
        {
            "question": "How can you handle user authorization and security rules in a Firebase-backed Flutter app?",
            "answer": "In a Firebase-backed Flutter app, user authorization is managed using Firebase Authentication (as discussed earlier). Firebase also allows defining security rules in Firestore and Firebase Storage to control who has read and write access to data. These rules can be based on the authenticated user's ID, roles, or other custom conditions. Developers can configure these rules in the Firebase console under the 'Firestore Database' or 'Storage' sections to ensure proper security for their app's data."
        },
        {
            "question": "Explain App state.",
            "answer": "App state refers to the data and variables that define the current condition or context of an application, including user inputs, UI elements, and application configurations, which can be global (shared across components) or local (specific to a component)."
        },
        {
            "question": "What are shared preferences in Flutter, and how are they used for persistent storage?",
            "answer": "Shared Preferences in Flutter is a key-value storage mechanism used to store small amounts of data persistently, such as user settings or simple app state. The `shared_preferences` package is used to read and write values to disk. This storage is typically used for small pieces of data like boolean flags, strings, integers, or lists. It is suitable for settings or user preferences that need to persist across app launches."
        },
        {
            "question": "What are the different build modes in Flutter?",
            "answer": "Flutter has three build modes: Debug (used during development with hot reload and detailed error messages), Profile (optimized for performance profiling with some debugging tools enabled), and Release (fully optimized for production with no debugging overhead)."
        },
        {
            "question": "How can we create HTTP requests in Flutter?",
            "answer": "In Flutter, HTTP requests can be created using the `http` package. You can use methods like `http.get()`, `http.post()`, `http.put()`, etc., to make requests to APIs and handle responses asynchronously using `Future`."
        },
        {
            "question": "Name two database packages mostly used in Flutter.",
            "answer": "Two commonly used database packages in Flutter are `sqflite` for local SQLite database management and `hive` for lightweight NoSQL storage."
        },
        {
            "question": "What is await in Flutter? Write its usage.",
            "answer": "In Flutter, `await` is used to pause the execution of an asynchronous function until a `Future` completes. It allows waiting for the result of a `Future` without blocking the main thread. It is typically used with `async` functions to handle asynchronous operations like HTTP requests or file reading."
        },
        {
            "question": "How can you store and retrieve data using shared preferences in Flutter?",
            "answer": "To store data using shared preferences in Flutter, you can use the `shared_preferences` package. First, you need to import the package and create an instance of `SharedPreferences`. Then, you can use methods like `setString()`, `setInt()`, `setBool()`, etc., to store data. To retrieve data, you can use the corresponding getter methods like `getString()`, `getInt()`, `getBool()`. Example: \n```\nSharedPreferences prefs = await SharedPreferences.getInstance();\nprefs.setString('username', 'JohnDoe');\nString? username = prefs.getString('username');\n```"
        },
        {
            "question": "Explain the limitations and suitable use cases for shared preferences in a Flutter app.",
            "answer": "Shared Preferences are ideal for storing small amounts of simple data (e.g., user settings, app configurations) that need to persist across app launches. However, they have limitations: \n1. They are not suitable for storing large datasets, such as images or complex objects. \n2. They do not provide encryption or secure storage out of the box. For sensitive data, you should consider using more secure options like the `flutter_secure_storage` package. Shared preferences should be used only for simple and lightweight data persistence."
        },
        {
            "question": "Explain the need for state management in Flutter and the challenges it addresses.",
            "answer": "State management in Flutter is essential for efficiently managing the app's state across different widgets and ensuring the UI remains synchronized with the underlying data. Flutter's declarative UI framework requires effective state management to handle dynamic content, especially in complex applications. Without proper state management, the app may face challenges like UI inconsistencies, difficulty in managing shared states, and poor performance. Different approaches, like setState, Provider, Riverpod, and BLoC, help address these issues by enabling better state control and reducing redundancy in code."
        },
        {
            "question": "What is the role of the setState method in managing widget state in Flutter?",
            "answer": "The `setState` method in Flutter is used to notify the framework that the internal state of a `StatefulWidget` has changed and that the widget needs to be rebuilt with the new state. It triggers a re-render of the widget and its descendants by calling the `build()` method again, allowing the UI to reflect the updated data. `setState` is mainly suitable for small applications or localized state changes, but for larger apps, more advanced state management techniques are recommended."
        },
        {
            "question": "How does the Provider package facilitate state management in Flutter?",
            "answer": "The `Provider` package is a popular and efficient state management solution in Flutter. It allows for sharing and managing state across different widgets by using a combination of InheritedWidget and ChangeNotifier. With `Provider`, you can create a model that holds the state and use it in different parts of the widget tree, without the need for passing data manually through constructors. `Provider` helps in managing app-wide state, making it easier to manage complex state and avoid issues like widget tree rebuilds."
        },
        {
            "question": "Explain the concept of 'immutable state' and its benefits in Flutter app development.",
            "answer": "'Immutable state' refers to the idea that once a piece of data is created, it cannot be modified directly. Instead, when the state changes, a new copy of the state is created with the updated values. This immutability ensures predictability, eliminates side effects, and makes state changes easier to manage and debug. In Flutter, immutable state makes it easier to manage complex UI changes, allows for better performance optimization, and simplifies state synchronization across multiple widgets."
        },
        {
            "question": "How can you secure your Flutter app by implementing role-based authorization?",
            "answer": "Role-based authorization can be implemented in Flutter by using Firebase Authentication in combination with Firestore security rules or by creating custom role-based access management on the server. After authenticating the user, you can assign roles to users (e.g., admin, user, guest) either in the Firebase console or via custom backend logic. Then, based on the user's role, you can control access to certain features or resources in the app. This ensures that only authorized users can access sensitive parts of the app."
        },
        {
            "question": "How can you implement user authentication using Firebase in a Flutter app?",
            "answer": "Firebase Authentication can be implemented in Flutter using the `firebase_auth` package. After setting up Firebase in your project, you can use methods like `signInWithEmailAndPassword`, `createUserWithEmailAndPassword`, and `signInWithGoogle` to authenticate users. Firebase handles authentication, user sessions, and security, and it also provides features like email verification, password reset, and social media logins (Google, Facebook, etc.). You can also use `onAuthStateChanged` to listen for user authentication changes and handle app navigation accordingly."
        },
        {
            "question": "Describe OAuth2 authentication and how it's used for third-party login in Flutter.",
            "answer": "OAuth2 is an authorization framework that allows users to log into a Flutter app using third-party services, like Google, Facebook, or Twitter, without sharing their credentials directly with the app. In Flutter, OAuth2 can be implemented using libraries like `flutter_oauth`, `google_sign_in`, or `flutter_facebook_auth`. These packages provide a secure method to authenticate users by obtaining an authorization token from the third-party service, which can then be used to access user data from that service."
        },
        {
            "question": "What are JWT (JSON Web Tokens), and how are they used for authentication in Flutter?",
            "answer": "JWT (JSON Web Tokens) are compact, URL-safe tokens that are used to securely transmit information between parties as a JSON object. In Flutter, JWT is commonly used for authentication by sending the token to the server after a user logs in. The server then verifies the token and provides access to protected resources. JWT tokens are typically used in combination with Firebase Authentication or custom backend authentication systems. They allow for stateless authentication and are useful for maintaining secure, long-lived sessions."
        },
        {
            "question": "What types of tests can you perform on a Flutter app, and why is testing important?",
            "answer": "Testing in Flutter is important to ensure the correctness, reliability, and maintainability of the app. The main types of tests in Flutter are: \n1. **Unit tests**: Test individual functions or methods in isolation. \n2. **Widget tests**: Test how widgets behave and interact with other widgets in the UI. \n3. **Integration tests**: Test the app as a whole, including interactions between widgets and external systems. These tests ensure that the app functions as expected, helps catch bugs early, and improves the overall quality of the app."
        },
        {
            "question": "Write the difference between runApp() and main() in Flutter.",
            "answer": "In Flutter, 'main()' is the entry point of the application, where the execution starts. 'runApp()' is called inside 'main()', and it takes a widget (typically the root widget) and attaches it to the screen, initializing the Flutter framework and rendering the app UI."
        },
        {
            "question": "Explain the purpose of unit tests, integration tests, and widget tests in Flutter.",
            "answer": "In Flutter, unit tests, integration tests, and widget tests serve different purposes: \n1. **Unit tests**: Focus on testing individual functions, methods, or classes to verify that they perform correctly in isolation. \n2. **Widget tests**: Focus on testing the behavior of UI components, checking whether widgets display the correct content, handle user interaction, and respond to changes in state. \n3. **Integration tests**: Test the entire app or large parts of it to ensure that different components work together as expected, such as testing API calls, navigation, and data storage."
        },
        {
            "question": "Difference between a StatelessWidget and a StatefulWidget in Flutter?",
            "answer": "A **StatelessWidget** is a widget that does not maintain any mutable state. Once created, it cannot change its appearance or properties. It is immutable and used when the UI depends entirely on the configuration passed to the widget. Examples include buttons, text labels, and icons.\n\nA **StatefulWidget**, on the other hand, is a widget that can hold mutable state and can rebuild itself when the state changes. It consists of two classes: the StatefulWidget itself and the associated State class, which holds the mutable state and can trigger a widget rebuild. StatefulWidgets are used when the UI depends on dynamic data that can change over time, like forms or animations."
        },
        {
            "question": "How would you execute code only in debug mode?",
            "answer": "In Flutter, you can execute code only in debug mode using the 'assert' function or by checking the 'kDebugMode' constant from the 'foundation.dart' package, which evaluates to true in debug mode and false in release builds."
        },
        {
            "question": "Write the difference between SizedBox Vs Container.",
            "answer": "A `SizedBox` is a lightweight widget used to create a fixed-size box with optional padding or margin, typically used for spacing between widgets. A `Container` is a more flexible widget that can apply decoration (like color, borders, shadows), padding, margin, constraints, and transformations, making it more versatile than `SizedBox`."
        },
        {
            "question": "What do you mean by Null-aware operators?",
            "answer": "Null-aware operators in Dart are used to handle null values gracefully. The most commonly used ones are `?.` (to call methods or access properties on an object only if it is not null), `??` (provides a default value when the left operand is null), and `??=` (assigns a value to a variable only if it is null)."
        },
        {
            "question": "What is the use of Mixins?",
            "answer": "Mixins are used in Dart to share functionality between multiple classes without requiring inheritance, allowing classes to reuse methods and properties from a mixin by using the 'with' keyword."
        },
        {
            "question": "How does Flutter manage animations, and what is the role of the Ticker and AnimationController?",
            "answer": "Flutter manages animations through its animation library, which provides fine-grained control over transitions and movements. A Ticker is a utility that signals the AnimationController about frame updates, ensuring that animations are synced with the screen's refresh rate. AnimationController is used to control the animation's lifecycle, such as starting, stopping, or repeating animations. It works with Tween objects to interpolate values and Curve classes to define animation easing. For example, you can use a Ticker with an AnimationController to create a fade-in effect by interpolating opacity values over time."
        },
        {
            "question": "How do you convert a list into map in Dart?",
            "answer": "You can convert a list into a map in Dart using the `asMap()` method, which returns a map where the keys are the list indices. Alternatively, you can use the `map()` function to create a map based on custom logic."
        },
        {
            "question": "How to compare 2 dates that are constructed differently in Dart?",
            "answer": "In Dart, you can compare two dates that are constructed differently by converting both to `DateTime` objects using `DateTime.parse()` or creating `DateTime` instances directly, and then using comparison operators (e.g., `==`, `<`, `>`) to compare them."
        },
        {
            "question": "What is the difference between double.INFINITY and MediaQuery?",
            "answer": "`double.INFINITY` represents a constant that represents positive infinity for floating-point values in Dart. On the other hand, `MediaQuery` is a Flutter class that provides information about the device's screen size, resolution, and other media-related properties, such as orientation and device pixel ratio."
        },
        {
            "question": "What is the difference between these operators ?? and ?",
            "answer": "In Dart, `??` is the null-aware operator, used to provide a default value if the left-hand operand is `null`. For example, `a ?? b` returns `a` if `a` is not `null`, otherwise returns `b`. `?` is used for null-aware method or property access, allowing you to call methods or access properties on objects that may be `null`, like `object?.method()`. If the object is `null`, it returns `null` without throwing an error."
        },
        {
            "question": "How is AnimationController different from Timer?",
            "answer": "An `AnimationController` in Flutter is a special type of controller used for animations, which can control the duration, repeat behavior, and progress of an animation, linked to a `Ticker` for continuous updates. A `Timer`, on the other hand, is used for executing a function after a set duration or repeatedly at fixed intervals, but it does not manage animations or frame updates."
        },
        {
            "question": "Explain Flutter Inspector",
            "answer": "Flutter Inspector is a powerful debugging tool in Flutter that allows developers to visually inspect and diagnose widget trees, understand layouts, and analyze rendering issues in real-time, helping to optimize UI development and debugging."
        },
        {
            "question": "Explain packages and plugins in Flutter.",
            "answer": "In Flutter, packages provide reusable functionality written in Dart, while plugins are a type of package that includes platform-specific code to access native features like camera or GPS on Android and iOS."
        },
        {
            "question": "What is a Navigator and what are Routes in Flutter?",
            "answer": "In Flutter, the **Navigator** is a widget that manages a stack of routes and handles the navigation between screens. Routes represent the different views or pages in the app, and the Navigator pushes and pops routes to navigate between them. When a route is pushed onto the stack, the current view is pushed off the screen, and when popped, the previous route becomes visible.\n\n**Routes** are essentially the different screens or pages in the app, defined using `MaterialPageRoute`, `CupertinoPageRoute`, or named routes. Routes can be defined in the `Navigator` using the `Navigator.push()` and `Navigator.pop()` methods for navigation."
        },
        {
            "question": "How does the Navigator 2.0 API differ from Navigator 1.0 in Flutter?",
            "answer": "Navigator 2.0 introduces declarative navigation to Flutter, enabling developers to define the navigation stack as a list of pages in a single location. This approach gives more control over navigation state and is useful for apps with complex routing requirements, such as deep linking or authentication flows. Navigator 1.0 uses an imperative approach with methods like `push()` and `pop()`, while Navigator 2.0 allows you to use Router, RouteInformationParser, and RouterDelegate to define and manage the navigation stack declaratively."
        },
        {
            "question": "Explain the concept of 'composition over inheritance' in Flutter's widget system.",
            "answer": "In Flutter, 'composition over inheritance' means that instead of creating subclasses to extend functionality, you compose widgets together to achieve the desired behavior. Flutter's widget system is designed to encourage combining simple widgets to build more complex UIs. This approach promotes better code maintainability and flexibility. For example, rather than subclassing a custom widget to add more features, you can compose existing widgets (such as `Container`, `Column`, `Row`, etc.) with different configurations to create new layouts or functionality."
        },
        {
            "question": "Explain Container class in Flutter.",
            "answer": "The Container class in Flutter is a versatile widget that allows you to customize the appearance and behavior of a box. It can be used to apply padding, margin, decoration (like color or border), constraints, and transform properties to its child widget, providing a flexible layout element in Flutter's UI."
        },
        {
            "question": "What is the role of a RouterDelegate and RouteInformationParser in Navigator 2.0?",
            "answer": "In Navigator 2.0, the RouterDelegate is responsible for managing the navigation stack and building the corresponding pages based on the state. It listens for changes in the navigation state and updates the UI accordingly. The RouteInformationParser, on the other hand, is used to parse route information into a state that the RouterDelegate can understand. This decouples the URL or route logic from the UI and allows for more declarative navigation, supporting deep linking and back/forward navigation in a more structured way."
        },
        {
            "question": "What are the trees available in Flutter? Eg: Widget Tree, Element Tree…",
            "answer": "In Flutter, there are three main trees that the framework uses for rendering the UI:\n\n1. **Widget Tree**: The widget tree is the structure that represents all the widgets in the application. It is a declarative, immutable structure where each widget describes part of the user interface.\n\n2. **Element Tree**: The element tree represents instances of widgets that are created during the app’s runtime. It connects widgets with their respective render objects, like size, position, and other properties. Unlike widgets, elements are mutable.\n\n3. **Render Object Tree**: The render object tree represents the layout and painting information of the UI components. Each render object is responsible for painting itself and its children to the screen. The render object tree is the actual visual representation of the widget tree, and Flutter uses it to layout and render the UI efficiently."
        },
        {
            "question": "How does Flutter achieve high performance and smooth UI rendering?",
            "answer": "Flutter achieves high performance and smooth UI rendering by utilizing its own rendering engine, Skia. Unlike traditional frameworks that rely on native UI components, Flutter draws everything from scratch, allowing for consistent performance across different platforms. Widgets in Flutter are lightweight, and the framework uses a declarative approach, which minimizes expensive re-renders. Furthermore, Flutter's Hot Reload feature boosts developer productivity by providing instant feedback during development."
        },
        {
            "question": "What are Keys in Flutter?",
            "answer": "Keys are used in Flutter to preserve the state of widgets when they are moved within the widget tree."
        },
        {
            "question": "Why are Keys important in widget trees?",
            "answer": "Keys help Flutter identify which widget should be reused rather than recreated, improving performance and preventing UI glitches."
        },
        {
            "question": "When should one use Keys in Flutter?",
            "answer": "Keys should be used in situations where the widget tree structure changes dynamically, such as in lists or when elements are reordered. They help ensure proper state preservation and optimize performance in such cases."
        },
        {
            "question": "What is the purpose of Constraints in Flutter, and how do they affect widget layout?",
            "answer": "Constraints in Flutter define the maximum and minimum width and height that a widget can occupy. Widgets use constraints to decide their size and layout within the parent. Constraints are passed down the widget tree during the layout phase, and widgets must respect them. For instance, a `Container` inside a `Flexible` widget will resize itself based on the constraints provided by the `Flexible`. Understanding and debugging constraints is essential for building responsive and adaptive UIs in Flutter."
        },
        {
            "question": "Explain pubspec.yaml file.",
            "answer": "The `pubspec.yaml` file in Flutter is a configuration file that defines the metadata, dependencies, assets, and other settings for a Flutter project. It specifies the project name, version, dependencies (both package and Flutter-specific), and assets like images or fonts to be used in the app. This file is essential for managing the project's external libraries and resources."
        },
        {
            "question": "What is the role of the BuildOwner and Element in Flutter's widget lifecycle?",
            "answer": "The BuildOwner is a central object that manages the lifecycle of the widget tree, including build, layout, and painting phases. It tracks dirty elements (elements needing an update) and ensures they are rebuilt efficiently. The Element is a bridge between widgets and RenderObjects, representing the runtime version of widgets in the widget tree. It keeps track of the relationship between widgets and their underlying RenderObjects. Together, BuildOwner and Element coordinate updates and optimize the performance of the widget tree."
        },
        {
            "question": "What is a RenderObject in Flutter, and how is it different from Widgets?",
            "answer": "A RenderObject in Flutter is a low-level component responsible for layout, painting, and hit-testing in the render tree. It represents the actual visual elements on the screen. Widgets, on the other hand, are lightweight configurations or blueprints that describe how the UI should look. While widgets are immutable and represent the structure of the UI, RenderObjects manage the heavy lifting of rendering and are mutable to optimize performance. For example, a Text widget creates a RenderParagraph RenderObject that handles text layout and rendering."
        },
        {
            "question": "What is the difference between ValueNotifier and ChangeNotifier in Flutter?",
            "answer": "ValueNotifier is a simple mechanism for managing and notifying listeners about changes to a single value. It is lightweight and best suited for scenarios with a single state variable. ChangeNotifier, on the other hand, is more robust and can notify listeners about multiple state changes. It is commonly used in Provider-based state management solutions. For example, use ValueNotifier for a counter app and ChangeNotifier for a form where multiple fields need to notify listeners of changes."
        },
        {
            "question": "How do InheritedWidget and Provider differ in state management?",
            "answer": "InheritedWidget is a built-in mechanism in Flutter that allows data to be efficiently shared across the widget tree without the need for explicit passing through constructors. However, it has limitations, such as being less intuitive and harder to scale in complex applications. Provider is a higher-level abstraction built on top of InheritedWidget. It simplifies state management by providing a more declarative API and integrating with dependency injection patterns. Provider also supports features like listening for updates and automatically rebuilding dependent widgets."
        },
        {
            "question": "How does Flutter implement platform-specific code using platform channels?",
            "answer": "Flutter allows communication between Dart code and native platform code (iOS and Android) through platform channels. A platform channel consists of a MethodChannel in Flutter and corresponding native code in Java/Kotlin (Android) or Swift/Objective-C (iOS). Data is passed between Dart and native code as asynchronous messages encoded in a standard format like JSON. This mechanism is used to access platform-specific features, such as camera or Bluetooth, that are not available in Flutter’s widget library."
        },
        {
            "question": "What is the difference between synchronous and asynchronous streams in Dart?",
            "answer": "Synchronous streams emit events immediately as they are added to the stream and must be listened to at the time of event emission. They are used for scenarios where events are produced and consumed within the same synchronous context. Asynchronous streams, on the other hand, emit events asynchronously and can handle listeners attaching after events are emitted. They are useful for handling events from external sources, such as user input, network responses, or file operations. Asynchronous streams are more common in Flutter apps, especially when dealing with futures or real-time updates."
        },
        {
            "question": "What is the difference between a BuildContext used in a StatelessWidget and in a StatefulWidget?",
            "answer": "In a StatelessWidget, the BuildContext is tied directly to the widget's build method and does not change during its lifecycle since the widget itself is immutable. In a StatefulWidget, the BuildContext is tied to the State object, which persists even when the widget is rebuilt. This allows StatefulWidget to manage dynamic updates while maintaining access to the same BuildContext. For example, in a StatefulWidget, the context can be used to retrieve ancestors or perform actions like showing a dialog even after state updates."
        },
        {
            "question": "What is the purpose of a custom Sliver and when would you use it?",
            "answer": "A custom Sliver in Flutter is used to create complex scrolling effects or layouts that are not possible with standard widgets. Slivers are building blocks for scrollable areas in Flutter, and they allow fine-grained control over how content is rendered, laid out, and scrolled. For example, you can create a custom Sliver to implement a collapsible header, parallax scrolling, or a staggered grid layout. To build a custom Sliver, you extend classes like RenderSliver and define layout, painting, and hit-testing behavior."
        },
        {
            "question": "How does Flutter handle widget lifecycles, and what are the key lifecycle methods in a StatefulWidget?",
            "answer": "Flutter manages the lifecycle of StatefulWidget through the State object, which contains several key lifecycle methods: \n1. `initState()`: Called once when the widget is first inserted into the widget tree, ideal for one-time initialization.\n2. `didChangeDependencies()`: Called after `initState` or when an InheritedWidget ancestor changes.\n3. `build()`: Called whenever the widget needs to be redrawn.\n4. `setState()`: Triggers a rebuild with updated state.\n5. `deactivate()`: Called when the widget is removed from the tree temporarily.\n6. `dispose()`: Called when the widget is permanently removed, used for cleanup. Understanding these methods is crucial for managing resources and ensuring smooth app behavior."
        },
        {
            "question": "What is the difference between FutureBuilder and StreamBuilder in Flutter?",
            "answer": "FutureBuilder is used to handle a single asynchronous computation represented by a Future, while StreamBuilder is used to handle continuous or multiple asynchronous data events from a Stream. FutureBuilder rebuilds the widget tree once the Future completes, whereas StreamBuilder can rebuild the UI every time a new event is emitted by the Stream. FutureBuilder is ideal for tasks like fetching data from an API once, while StreamBuilder is suited for real-time data updates, such as a chat app or stock price updates."
        },
        {
            "question": "How do you optimize Flutter app performance when dealing with large lists?",
            "answer": "To optimize performance for large lists in Flutter, use `ListView.builder` or `ListView.separated` instead of `ListView` to build items lazily as they are scrolled into view. Additionally, you can use the `const` constructor for widgets that do not change to avoid unnecessary rebuilds. Implement caching mechanisms like `CachedNetworkImage` for images and avoid heavy computations in the build method by precomputing data. For advanced use cases, use `ReorderableListView` or `SliverList` for further customization and performance tuning."
        },
        {
            "question": "What are Flutter hooks, and how do they simplify state management?",
            "answer": "Flutter hooks are a community package (`flutter_hooks`) that introduces reusable logic and lifecycle management into functional-style widgets, similar to React Hooks. Hooks eliminate boilerplate code associated with StatefulWidgets by encapsulating stateful behavior in custom hooks. For example, you can use `useState` for simple state management or `useEffect` to handle side effects. Hooks also provide advanced features like `useStream` and `useFuture` for asynchronous data handling, making code more concise and readable."
        },
        {
            "question": "What is a RepaintBoundary in Flutter, and how does it help improve performance?",
            "answer": "A RepaintBoundary is a widget that creates a separate layer for its child widget in the rendering tree. It isolates the child widget from its parent, ensuring that only the child is repainted when its visual appearance changes. This optimization reduces the number of widgets that need to be redrawn, especially in scenarios with heavy animations or dynamic UI updates. To use it, simply wrap the widget you want to isolate with `RepaintBoundary`. However, overusing it can increase memory usage, so it should be used judiciously."
        },
        {
            "question": "How would you handle multiple themes in a Flutter app dynamically?",
            "answer": "To handle multiple themes dynamically, use the `ThemeData` class along with the `Theme` widget. Store the selected theme in a `State` or state management solution like Provider or Riverpod. Update the app’s theme dynamically by wrapping the app in a `MaterialApp` and passing the selected `ThemeData` to the `theme` property. For example, you can toggle between light and dark themes based on user preferences or system settings by listening to changes using `MediaQuery` or `PlatformDispatcher`."
        },
        {
            "question": "Name some best editors for Flutter development.",
            "answer": "Some of the best editors for Flutter development include Visual Studio Code, Android Studio, IntelliJ IDEA, and Eclipse. These editors provide Flutter-specific plugins, debugging tools, and a smooth development experience."
        },
        {
            "question": "Name some apps that mostly use Flutter.",
            "answer": "Some popular apps built with Flutter include Google Ads, Alibaba, Reflectly, Nubank, and Hamilton. These apps leverage Flutter for its fast development, cross-platform support, and high performance."
        },
        {
            "question": "When to use mainAxisAlignment and crossAxisAlignment?",
            "answer": "In Flutter, use **mainAxisAlignment** to control the alignment of children along the main axis (horizontal for Row, vertical for Column), such as positioning items at the start, end, or center. Use **crossAxisAlignment** to align children along the cross axis (perpendicular to the main axis), such as aligning them at the top, center, or bottom in a Column or left, right, or center in a Row."
        },
        {
            "question": "Which one is better, Flutter or React Native?",
            "answer": "The choice between Flutter and React Native depends on your project requirements. Flutter offers high performance with a single codebase and a rich set of customizable widgets, making it ideal for creating visually appealing apps. React Native, on the other hand, has a larger community, a wider range of libraries, and allows developers to use JavaScript, making it a good option for teams familiar with web development. Ultimately, the decision should be based on your development preferences, team expertise, and project goals."
        },
        {
            "question": "What is the BloC pattern?",
            "answer": "The BloC (Business Logic Component) pattern is a design pattern used in Flutter for managing state and business logic in a reactive way. It separates the UI from the business logic by using streams to handle events and state changes."
        },
        {
            "question": "How does BloC work in Flutter?",
            "answer": "In Flutter, the BloC pattern works by using streams and sinks. The UI sends events to the BloC, which processes the events and outputs new states to the UI. The UI then listens for state changes and rebuilds accordingly. This creates a clean separation between the UI and business logic."
        },
        {
            "question": "What are the key advantages of using the BloC pattern in Flutter?",
            "answer": "Key advantages of using the BloC pattern in Flutter include better separation of concerns, easier testing, and reusability of business logic. It also enables a clear flow of data using streams, making the application scalable and maintainable."
        },
        {
            "question": "How do you implement BloC in Flutter?",
            "answer": "To implement BloC in Flutter, you create a `Bloc` class that handles events and emits states using streams. The UI interacts with the BloC by dispatching events and listening for state changes, typically using the `StreamBuilder` widget to build the UI based on the state."
        },
        {
            "question": "How do you handle navigation with BloC in Flutter?",
            "answer": "In BloC, navigation can be handled by emitting navigation events from the BloC, such as pushing new routes or showing dialogs. You can use a `StreamBuilder` or `BlocListener` to listen for navigation-related state changes and trigger the navigation actions accordingly."
        },
        {
            "question": "How do you test a BloC in Flutter?",
            "answer": "To test a BloC in Flutter, you can create unit tests using the `bloc_test` package, which allows you to simulate events and assert the expected states. You can also use mock objects and verify the behavior of the BloC under different conditions."
        },
        {
            "question": "Can you explain the concept of state management in BloC?",
            "answer": "In BloC, state management is handled by using streams and sinks. Events are dispatched to the BloC, which processes them and outputs new states. The UI listens to these states and rebuilds itself based on the new data. This makes state management predictable and decouples the business logic from the UI."
        },
        {
            "question": "What are the alternatives to BloC for state management in Flutter?",
            "answer": "Alternatives to BloC for state management in Flutter include Provider, Riverpod, Redux, MobX, and GetX. These frameworks offer different approaches to managing state, ranging from simple context-based management to more complex, reactive models."
        },
        {
            "question": "What is BlocProvider in Flutter BloC, and how is it used?",
            "answer": "`BlocProvider` is a widget in Flutter BloC that provides an instance of a BloC to the widget tree. It ensures that the BloC is available to all descendants that need it, typically by wrapping a portion of the widget tree with `BlocProvider` and passing the BloC instance to it."
        },
        {
            "question": "How do you use BlocProvider to provide a BloC instance to a widget tree?",
            "answer": "To use `BlocProvider`, wrap the widget tree or part of the tree with it and pass the BloC instance via the `create` parameter. For example: `BlocProvider(create: (context) => MyBloc(), child: MyWidget())` makes `MyBloc` available to `MyWidget` and its descendants."
        },
        {
            "question": "What is the purpose of BlocBuilder in Flutter BloC, and how does it work?",
            "answer": "`BlocBuilder` is a widget that listens to a BloC and rebuilds the widget whenever the state changes. It takes the current state from the BloC and allows you to build the UI based on the state. It works by listening to the state stream and triggering a rebuild when the state changes."
        },
        {
            "question": "How do you use BlocBuilder to listen to state changes in Flutter BloC?",
            "answer": "To use `BlocBuilder`, pass the BloC and the `builder` function to it. The `builder` function takes the current state as a parameter, and the widget is rebuilt with the new state. Example: `BlocBuilder<MyBloc, MyState>(builder: (context, state) => MyWidget(state))`."
        },
        {
            "question": "What is the purpose of BlocConsumer in Flutter BloC, and how does it differ from BlocBuilder?",
            "answer": "`BlocConsumer` combines both `BlocBuilder` and `BlocListener`. It listens to state changes and also allows handling side effects like navigation or showing a dialog when an event is triggered. Unlike `BlocBuilder`, which only rebuilds the UI, `BlocConsumer` can also perform actions based on state changes."
        },
        {
            "question": "How do you use BlocConsumer in Flutter BloC to handle events and state changes?",
            "answer": "To use `BlocConsumer`, pass the `builder` and `listener` functions. The `builder` function rebuilds the UI based on state changes, while the `listener` function handles side effects (e.g., navigation, showing snackbars). Example: `BlocConsumer<MyBloc, MyState>(builder: (context, state) => MyWidget(state), listener: (context, state) { // Handle side effects })`."
        },
        {
            "question": "Can you explain the concept of context in Flutter BloC?",
            "answer": "In Flutter BloC, `context` is used to access the nearest BloC instance in the widget tree. It helps in retrieving the BloC using `BlocProvider.of(context)` or in accessing the `BuildContext` for widget-related tasks like navigation or showing dialogs. The context plays a crucial role in finding and interacting with BloC instances."
        },
        {
            "question": "What is the difference between 'listen when' and 'build when' in Flutter BloC?",
            "answer": "'listenWhen' is used in Flutter BloC to control when the `BlocListener` should react to state changes based on a specific condition. It allows you to listen to state changes but only trigger actions when a certain condition is met. On the other hand, 'buildWhen' is used in `BlocBuilder` to control when the widget should be rebuilt in response to state changes. It allows you to filter out unnecessary rebuilds by specifying when the UI should update based on changes in the state."
        }
    ],
    "html": [
        {
            "question": "What is HTML?",
            "answer": "HTML (HyperText Markup Language) is the standard markup language for creating web pages. It structures content on the web using elements like headings, paragraphs, and images."
        },
        {
            "question": "What are the differences between HTML and XHTML?",
            "answer": "HTML is more forgiving with syntax errors, while XHTML requires strict adherence to syntax rules. XHTML is XML-based and must be well-formed. XHTML elements must always be properly closed (e.g., <br />)."
        },
        {
            "question": "What are HTML tags? List a few examples.",
            "answer": "Tags are elements enclosed in angle brackets, like <p> (paragraph), <a> (link), <img> (image), etc."
        },
        {
            "question": "What are semantic HTML tags? And give examples.",
            "answer": "Tags that clearly describe their purpose: Examples: <header>, <footer>, <article>, <section>."
        },
        {
            "question": "What is the <nav> element?",
            "answer": "The <nav> element is used to define navigation links within a document. It is intended to group links that help users navigate the site or application, such as menus or sidebars. It helps search engines and assistive technologies identify and prioritize navigation sections. Example: <nav><ul><li><a href='#home'>Home</a></li><li><a href='#about'>About</a></li></ul></nav>."
        },
        {
            "question": "What is the difference between <div> and <span>?",
            "answer": "<div>: Block-level container. <span>: Inline container."
        },
        {
            "question": "What is the difference between the <head> and <body> sections of an HTML document?",
            "answer": "<head>: Contains metadata, title, links to CSS/JS. <body>: Contains visible content displayed on the webpage."
        },
        {
            "question": "What is the difference between a block-level element and an inline element?",
            "answer": "Block-level elements start on a new line (e.g., <div>, <h1>). Inline elements do not break the line (e.g., <span>, <a>)."
        },
        {
            "question": "What is the purpose of the <DOCTYPE> declaration?",
            "answer": "It tells the browser which version of HTML is used, ensuring proper rendering."
        },
        {
            "question": "What is the difference between `div` and `span` tags?",
            "answer": "The `<div>` tag is a block-level element, used to group content and structure a page, while the `<span>` tag is an inline element, used to style a part of a content without breaking the flow of text."
        },
        {
            "question": "What is the <main> element?",
            "answer": "The <main> element is used to represent the primary content of the document. It is intended to contain content that is directly related to or expands upon the central topic of the document, excluding things like headers, footers, navigation, and sidebars. There should only be one <main> element per document. Example: <main><h1>Main content here</h1></main>."
        },
        {
            "question": "What is the purpose of the <head> tag in HTML?",
            "answer": "The <head> tag in HTML is used to contain meta-information about the document, such as the document title, character encoding, links to stylesheets, scripts, and other resources. It is not directly visible on the webpage but provides important data to the browser and search engines."
        },
        {
            "question": "What is the difference between the `<ul>`, `<ol>`, and `<li>` tags?",
            "answer": "The `<ul>` tag creates an unordered list, the `<ol>` tag creates an ordered list, and the `<li>` tag defines list items inside either `<ul>` or `<ol>`."
        },
        {
            "question": "What does the `alt` attribute do in an `<img>` tag?",
            "answer": "The `alt` attribute provides alternative text for an image if it cannot be displayed, improving accessibility for users with screen readers or when the image fails to load."
        },
        {
            "question": "How do you create a hyperlink in HTML?",
            "answer": "To create a hyperlink, use the <a> tag with the href attribute to specify the URL."
        },
        {
            "question": "What is an anchor (`<a>`) tag used for?",
            "answer": "The `<a>` tag is used to define hyperlinks in a webpage. It links to other documents or sections within the same document using the `href` attribute."
        },
        {
            "question": "What is the difference between inline and block-level elements in HTML?",
            "answer": "Block-level elements occupy the full width available and start on a new line, such as `<div>`, `<section>`, and `<header>`. Inline elements, like `<span>`, do not break the flow of content and only take up as much width as necessary."
        },
        {
            "question": "How do you create a form in HTML?",
            "answer": "You can create a form using the `<form>` tag."
        },
        {
            "question": "What is the use of the `<label>` tag in a form?",
            "answer": "The `<label>` tag is used to define labels for `<input>`, `<textarea>`, `<select>`, and other form elements. It improves accessibility, allowing screen readers to associate the label with the corresponding input field."
        },
        {
            "question": "How do you include external CSS in an HTML document?",
            "answer": "You can include external CSS by using the `<link>` tag in the `<head>` section. Example:\n<link rel='stylesheet' href='styles.css'>"
        },
        {
            "question": "How do you add a background color to a web page in HTML?",
            "answer": "You can add a background color to a webpage byusing the style attribute in the <body> tag or through CSS."
        },
        {
            "question": "What is the difference between the `<link>` and `<script>` tags?",
            "answer": "The `<link>` tag is used to link external resources such as CSS files, while the `<script>` tag is used to include or link external JavaScript files."
        },
        {
            "question": "How can you make a table in HTML?",
            "answer": "A table is created using the `<table>` tag, with rows defined by the `<tr>` tag, header cells by the `<th>` tag, and data cells by the `<td>` tag. Example:\n<table>\n  <tr>\n    <th>Name</th>\n    <th>Age</th>\n  </tr>\n  <tr>\n    <td>John</td>\n    <td>25</td>\n  </tr>\n</table>"
        },
        {
            "question": "What does the `colspan` attribute do in a table?",
            "answer": "The `colspan` attribute in a `<td>` or `<th>` element specifies how many columns the cell should span across. Example: `<td colspan='2'>Cell</td>` will span 2 columns."
        },
        {
            "question": "What is the `<iframe>` tag used for?",
            "answer": "The `<iframe>` tag is used to embed another HTML document within the current document. Example: `<iframe src='https://example.com'></iframe>`."
        },
        {
            "question": "How do you create a contact form with text area in HTML?",
            "answer": "You can create a contact form with a text area by using the <textarea> tag."
        },
        {
            "question": "What is the difference between the `<b>` and `<strong>` tags?",
            "answer": "The `<b>` tag is used to make text bold, while the `<strong>` tag also makes text bold but has semantic meaning, indicating that the text is of strong importance."
        },
        {
            "question": "How can you include an external JavaScript file in HTML?",
            "answer": "You can include an external JavaScript file using the `<script>` tag. Example:\n<script src='script.js'></script>"
        },
        {
            "question": "What is the `viewport` meta tag used for?",
            "answer": "The `viewport` meta tag controls the layout on mobile devices, allowing you to set the width, zoom level, and scaling behavior. Example: `<meta name='viewport' content='width=device-width, initial-scale=1.0'>`."
        },
        {
            "question": "What is the difference between the `<head>` and `<body>` tags?",
            "answer": "The `<head>` tag contains metadata and links to external resources (like stylesheets), while the `<body>` tag contains the content that is visible on the page."
        },
        {
            "question": "How do you embed a video in HTML?",
            "answer": "You can embed a video by using the <video> tag. You can also include the controls attribute for video controls like play, pause, and volume."
        },
        {
            "question": "What is the difference between the `<section>` and `<div>` tags?",
            "answer": "The `<section>` tag is used for grouping related content with a semantic meaning, while the `<div>` tag is a generic container with no semantic meaning. `<section>` is better for accessibility and SEO."
        },
        {
            "question": "What does the `<audio>` tag do in HTML?",
            "answer": "The `<audio>` tag is used to embed audio content in a web page. It supports multiple file formats and can include controls like play, pause, and volume adjustment. Example:\n<audio controls>\n  <source src='audio.mp3' type='audio/mpeg'>\n  Your browser does not support the audio element.\n</audio>"
        },
        {
            "question": "What does the `<video>` tag do in HTML?",
            "answer": "The `<video>` tag is used to embed a video in a web page. It can include controls for play, pause, and volume, as well as support for multiple video file formats. Example:\n<video controls>\n  <source src='video.mp4' type='video/mp4'>\n  Your browser does not support the video element.\n</video>"
        },
        {
            "question": "How do you specify multiple file inputs in a form?",
            "answer": "You can allow multiple file selection by using the 'multiple' attribute on the <input type='file'> element, like this: <input type='file' multiple>."
        },
        {
            "question": "What are the attributes of the `<form>` tag and what do they do?",
            "answer": "The most common attributes of the `<form>` tag are `action` (specifies where to send form data) and `method` (defines the HTTP method, usually 'GET' or 'POST'). Example:\n<form action='/submit' method='post'>\n</form>"
        },
        {
            "question": "What is the difference between the `<input>` types `text`, `password`, and `email`?",
            "answer": "The `<input type='text'>` is used for single-line text input, `<input type='password'>` hides the input for sensitive data, and `<input type='email'>` is used for email addresses with built-in validation for email format."
        },
        {
            "question": "How do you define a clickable button in HTML?",
            "answer": "You can define a clickable button using the `<button>` tag. Example:\n<button type='button' onclick='alert(\"Button clicked!\")'>Click Me</button>"
        },
        {
            "question": "How do you create a dropdown list in HTML?",
            "answer": "You can create a dropdown list using the `<select>` and `<option>` tags. Example:\n<select>\n  <option value='1'>Option 1</option>\n  <option value='2'>Option 2</option>\n</select>"
        },
        {
            "question": "How do you create a button in HTML?",
            "answer": "To create a button in HTML, you can use the <button> element or the <input> element with type='button'. The <button> element is more versatile, as it can contain text or HTML content, whereas the <input> element is used for simple buttons."
        },
        {
            "question": "What is the `charset` attribute in the `<meta>` tag?",
            "answer": "The `charset` attribute in the `<meta>` tag specifies the character encoding for the HTML document, which helps ensure the correct rendering of text. Example: `<meta charset='UTF-8'>`."
        },
        {
            "question": "What are the new form input types introduced in HTML5?",
            "answer": "HTML5 introduced several new input types, including `email`, `url`, `date`, `time`, `range`, `number`, `tel`, and `search`, among others, to provide better user input validation and control."
        },
        {
            "question": "What is the <time> element used for?",
            "answer": "The <time> element is used to represent a specific period in time, such as a date, time, or a range of time. It allows the browser and search engines to better understand and format the content. Example: <time datetime='2024-11-20'>November 20, 2024</time>."
        },
        {
            "question": "What is the purpose of the `<noscript>` tag?",
            "answer": "The `<noscript>` tag is used to define content that is displayed if the user's browser does not support JavaScript or if JavaScript is disabled. Example:\n<noscript>Your browser does not support JavaScript.</noscript>"
        },
        {
            "question": "What does the `placeholder` attribute do in HTML forms?",
            "answer": "The `placeholder` attribute provides a short hint inside an input field to describe the expected value. It disappears when the user starts typing. Example:\n<input type='text' placeholder='Enter your name'>"
        },
        {
            "question": "What are the different types of lists in HTML?",
            "answer": "There are three types of lists in HTML: unordered list (`<ul>`), ordered list (`<ol>`), and definition list (`<dl>`), which is used to define terms and their descriptions."
        },
        {
            "question": "How do you create an ordered list in HTML?",
            "answer": "An ordered list can be created using the <ol> tag, and each item is defined with the <li> tag."
        },
        {
            "question": "What is the use of the `<mark>` tag?",
            "answer": "The `<mark>` tag is used to highlight text, typically for search results or important keywords. Example:\n<p>This is an <mark>important</mark> note.</p>"
        },
        {
            "question": "What is the `action` attribute of the `<form>` tag?",
            "answer": "The `action` attribute specifies the URL where the form data should be submitted. Example:\n<form action='submit_form.php' method='post'>"
        },
        {
            "question": "What is the `method` attribute in the `<form>` tag?",
            "answer": "The `method` attribute defines how the form data is sent to the server. It can be `GET` (data is appended to the URL) or `POST` (data is sent in the request body). Example:\n<form method='post'>"
        },
        {
            "question": "How do you create a table in HTML?",
            "answer": "You can create a table using the `<table>`, `<tr>`, `<th>`, and `<td>` tags. Example:\n<table>\n  <tr>\n    <th>Name</th>\n    <th>Age</th>\n  </tr>\n  <tr>\n    <td>John</td>\n    <td>25</td>\n  </tr>\n</table>"
        },
        {
            "question": "How do you make text italic in HTML?",
            "answer": "You can make text italic using the `<i>` or `<em>` tag. The `<em>` tag also gives semantic meaning (emphasis). Example:\n<p><i>Italic text</i></p>"
        },
        {
            "question": "What is the difference between `<strong>` and `<b>` tags?",
            "answer": "The `<strong>` tag is used to indicate that the text is of strong importance (semantically meaningful), while the `<b>` tag is used for styling purposes to make the text bold without semantic meaning."
        },
        {
            "question": "What is the `target='_blank'` attribute used for in an anchor tag?",
            "answer": "The `target='_blank'` attribute causes the link to open in a new tab or window."
        },
        {
            "question": "How do you specify a character encoding for an HTML document?",
            "answer": "To specify a character encoding for an HTML document, you use the <meta> tag with the 'charset' attribute in the <head> section of the HTML document. The most common encoding is UTF-8."
        },
        {
            "question": "How do you define an image map?",
            "answer": "An image map is defined using the <map> element, which contains one or more <area> elements that define clickable areas on an image. Each <area> element specifies a shape (like rectangle, circle, or polygon) and links to a target."
        },
        {
            "question": "What is the difference between the <em> and <i> tags in HTML?",
            "answer": "The <em> tag is used to emphasize text, which is typically displayed in italics by default. It also has semantic meaning, indicating that the text should be emphasized or stressed, which can affect screen readers or search engines. The <i> tag is used to apply italic styling to text without implying any special emphasis or meaning. It is purely a presentational element and does not carry semantic meaning."
        },
        {
            "question": "What is the difference between id and class attributes?",
            "answer": "The 'id' attribute is used to uniquely identify an element within a document. It must have a unique value on the page, meaning no two elements can share the same 'id'. It is commonly used for targeting a specific element with JavaScript or CSS. The 'class' attribute is used to assign one or more class names to an element, which can be shared across multiple elements. It is useful for applying the same styles or behaviors to multiple elements."
        },
        {
            "question": "What is the <fieldset> tag used for in HTML forms?",
            "answer": "The <fieldset> tag is used to group related elements within an HTML form, often with a visual border, to improve form organization and accessibility. It helps in organizing complex forms into sections. The <legend> tag is often used inside a <fieldset> to provide a title for the group. Example: <fieldset><legend>Personal Information</legend><input type='text' name='name'></fieldset>."
        },
        {
            "question": "What is the difference between <link> and <a> tags?",
            "answer": "The <link> tag is used to define relationships between the current document and external resources, such as linking a CSS stylesheet or a favicon. It is placed in the <head> section of the HTML document and does not create clickable content on the page. The <a> (anchor) tag is used to create hyperlinks that navigate to other web pages or resources. It is placed within the body of the document and can be clicked by users to navigate."
        },
        {
            "question": "What is the <canvas> tag?",
            "answer": "The <canvas> tag is used to draw graphics, such as shapes, images, and animations, on the fly using JavaScript. It provides an area on the webpage where you can programmatically render content. Example: <canvas id='myCanvas' width='200' height='100'></canvas> allows for drawing inside the specified width and height. JavaScript methods, such as 'getContext()' and drawing functions, are used to interact with the canvas."
        },
        {
            "question": "What are data attributes in HTML?",
            "answer": "Data attributes in HTML allow you to store extra information on an element without affecting its rendering. They are prefixed with 'data-', followed by a custom name. For example, <div data-user-id='1234'> stores a custom 'user-id' attribute. You can access data attributes using JavaScript via 'element.dataset'."
        },
        {
            "question": "What is the <aside> element used for?",
            "answer": "The <aside> element is used to represent content that is tangentially related to the content around it. It typically contains information like sidebars, call-out boxes, or additional resources that are indirectly related to the main content. Example: <aside><p>Related articles or links</p></aside>."
        },
        {
            "question": "What is the `<progress>` tag?",
            "answer": "The <progress> tag is used to represent the progress of a task, such as downloading, uploading, or completing a process. It displays a visual progress bar, where the 'value' attribute specifies the current progress, and the 'max' attribute defines the total value."
        },
        {
            "question": "How do you define a progress bar in HTML?",
            "answer": "A progress bar is defined using the <progress> tag. The value attribute represents the current progress, and the max attribute defines the maximum value. Example: <progress value='50' max='100'></progress>."
        },
        {
            "question": "What are semantic HTML elements?",
            "answer": "They are elements with meaningful names that describe their purpose, such as `<header>`, `<footer>`, and `<article>`."
        },
        {
            "question": "What is the `download` attribute in an `<a>` tag?",
            "answer": "It enables files to be downloaded instead of being opened in the browser."
        },
        {
            "question": "What are HTML entities?",
            "answer": "HTML entities are special characters that are represented by a code or name, used to display reserved or non-printable characters in HTML. They are used to ensure that characters are displayed correctly in the browser without interfering with the HTML code. For example, the less-than symbol (<) is represented as &lt;, and the ampersand (&) is represented as &amp;."
        },
        {
            "question": "What is the `<datalist>` tag?",
            "answer": "It provides a list of predefined options for an input field."
        },
        {
            "question": "How do you disable an input field?",
            "answer": "Add the `disabled` attribute to the input field."
        },
        {
            "question": "What is the purpose of the `<details>` and `<summary>` tags?",
            "answer": "The `<details>` tag is used to create a collapsible content area that users can toggle open or closed. The `<summary>` tag is placed inside the `<details>` element and serves as a summary or label for the content. Together, they provide an easy way to hide or show information interactively without requiring JavaScript."
        },
        {
            "question": "What is the purpose of the doctype declaration?",
            "answer": "The <!DOCTYPE> declaration specifies the HTML version being used and ensures that the browser renders the page in standards mode rather than quirks mode, providing consistent behavior across different browsers."
        },
        {
            "question": "How do you add a favicon to a website?",
            "answer": "A favicon can be added to a website by including a <link> tag in the <head> section of the HTML document, pointing to the image file you want to use as the favicon. Example: <link rel='icon' href='favicon.ico' type='image/x-icon'>."
        },
        {
            "question": "How do you include JavaScript in HTML?",
            "answer": "JavaScript can be included in HTML using the <script> tag. It can be placed either in the <head> or <body> section. You can include external JavaScript files by using the 'src' attribute, like this: <script src='script.js'></script>. Alternatively, you can write inline JavaScript within the <script> tags: <script>console.log('Hello, World!');</script>."
        }
    ],
    "javascript": [
        {
            "question": "What is JavaScript?",
            "answer": "JavaScript is a lightweight, interpreted programming language primarily used to make web pages interactive."
        },
        {
            "question": "What are JavaScript data types?",
            "answer": "Primitive types: String, Number, Boolean, Undefined, Null, Symbol, BigInt. Non-primitive types: Object, Array, Function."
        },
        {
            "question": "What is the difference between synchronous and asynchronous programming?",
            "answer": "Synchronous: Code is executed sequentially. Asynchronous: Code execution doesn't block; tasks run in the background, e.g., using callbacks, promises, or async/await."
        },
        {
            "question": "What is the difference between call(), apply(), and bind()?",
            "answer": "call: Invokes a function with a specified this value and arguments passed individually. apply: Similar to call, but arguments are passed as an array. bind: Returns a new function with a specified this value and arguments."
        },
        {
            "question": "What is the difference between deep copy and shallow copy?",
            "answer": "Shallow copy: Copies only the first level of properties. Deep copy: Recursively copies all levels of properties."
        },
        {
            "question": "What are arrow functions?",
            "answer": "Arrow functions provide a concise way to define functions and do not have their own this or arguments binding."
        },
        {
            "question": "What is the difference between null and undefined?",
            "answer": "null is an intentionally empty value, while undefined means a variable has been declared but not assigned a value."
        },
        {
            "question": "What is the difference between map(), filter(), and reduce()?",
            "answer": "map transforms each element in an array, filter returns elements that match a condition, and reduce aggregates array elements into a single value."
        },
        {
            "question": "What is the difference between mutable and immutable data types?",
            "answer": "Mutable data types can be changed after creation (e.g., objects, arrays), while immutable data types cannot be changed (e.g., strings, numbers)."
        },
        {
            "question": "What is prototypal inheritance?",
            "answer": "Prototypal inheritance is a way to share properties and methods between objects via their prototype."
        },
        {
            "question": "What are modules in JavaScript?",
            "answer": "Modules are reusable pieces of JavaScript code that can be exported and imported using keywords like export and import."
        },
        {
            "question": "What is the difference between a shallow copy and a deep copy?",
            "answer": "A shallow copy copies only the first layer of an object, while a deep copy recursively copies all levels."
        },
        {
            "question": "What are JavaScript generators?",
            "answer": "Generators are functions that can pause execution and resume later, producing a series of values on demand using 'yield'."
        },
        {
            "question": "What is the difference between localStorage, sessionStorage, and cookies?",
            "answer": "localStorage stores data with no expiration. sessionStorage stores data for the session only. Cookies store data with expiration and are sent to the server with HTTP requests."
        },
        {
            "question": "What is the difference between function declarations and function expressions?",
            "answer": "Function declarations are hoisted, while function expressions are not. Declarations are named, expressions can be named or anonymous."
        },
        {
            "question": "What is the difference between Object.freeze() and Object.seal()?",
            "answer": "Object.freeze() prevents adding, removing, or modifying properties. Object.seal() prevents adding or removing properties but allows modifying existing properties."
        },
        {
            "question": "What is the difference between implicit and explicit binding in JavaScript?",
            "answer": "Implicit binding occurs when a function is called with an object before it (e.g., obj.method()). Explicit binding uses call(), apply(), or bind() to set 'this' explicitly."
        },
        {
            "question": "What is the Temporal Dead Zone (TDZ) in JavaScript?",
            "answer": "TDZ is the time between the declaration of a variable with let/const and its initialization, during which accessing it throws a ReferenceError."
        },
        {
            "question": "What is the purpose of the Symbol data type?",
            "answer": "Symbols are unique and immutable primitives used as keys for object properties, ensuring property uniqueness."
        },
        {
            "question": "What are WeakMap and WeakSet?",
            "answer": "WeakMap is a Map where keys are weakly referenced objects, and WeakSet is a Set that holds weakly referenced objects, allowing garbage collection."
        },
        {
            "question": "What is throttling in JavaScript?",
            "answer": "Throttling ensures a function is called at most once in a specified period, even if triggered multiple times."
        },
        {
            "question": "What is the difference between an abstract class and an interface in JavaScript?",
            "answer": "JavaScript does not have interfaces or abstract classes natively but can simulate them using ES6 classes or TypeScript."
        },
        {
            "question": "What is the use of the async keyword in JavaScript?",
            "answer": "The 'async' keyword is used to define an asynchronous function that returns a promise and allows the use of 'await' inside it."
        },
        {
            "question": "What are JavaScript design patterns?",
            "answer": "Design patterns are reusable solutions to common problems in software design, such as Singleton, Factory, and Observer patterns."
        },
        {
            "question": "What is optional chaining in JavaScript?",
            "answer": "Optional chaining (?.) allows safe access to nested object properties, returning undefined if a reference is nullish."
        },
        {
            "question": "What is dynamic typing in JavaScript?",
            "answer": "JavaScript is dynamically typed, meaning variables are not bound to a specific data type and can hold different types during execution."
        },
        {
            "question": "What is the difference between Array.splice() and Array.slice()?",
            "answer": "slice() returns a shallow copy of a portion of an array. splice() modifies the original array by adding/removing elements."
        },
        {
            "question": "What are JavaScript's escape sequences?",
            "answer": "Escape sequences are used to represent certain characters within strings that are difficult or impossible to represent directly, such as '\\n' for a newline, '\\t' for a tab, and '\\\"' for a double quote."
        },
        {
            "question": "What is the difference between Array.map() and Array.forEach()?",
            "answer": "map() creates a new array with the results of applying a function to each element, while forEach() executes a function for each element without returning a new array."
        },
        {
            "question": "What is a JavaScript callback?",
            "answer": "A callback is a function passed as an argument to another function, which is then executed after a certain event or task completes."
        },
        {
            "question": "What is the 'use strict' directive in JavaScript?",
            "answer": "'use strict' is a pragma that enables stricter parsing and error handling in JavaScript, avoiding some silent errors and unsafe actions."
        },
        {
            "question": "What is the difference between synchronous and asynchronous execution in JavaScript?",
            "answer": "Synchronous execution occurs sequentially, blocking further code execution until a task completes, while asynchronous execution allows code to run independently, using callbacks, promises, or async/await."
        },
        {
            "question": "What is the 'arguments' object in JavaScript?",
            "answer": "The 'arguments' object is an array-like object that contains all the arguments passed to a function, available within non-arrow functions."
        },
        {
            "question": "What is a polyfill in JavaScript?",
            "answer": "A polyfill is a piece of code that implements functionality that may be missing in some browsers or JavaScript environments, making newer features compatible with older ones."
        },
        {
            "question": "What is the 'prototype' property in JavaScript?",
            "answer": "The 'prototype' property allows you to add methods and properties to a constructor function's instances, enabling inheritance in JavaScript."
        },
        {
            "question": "What is JavaScript's NaN?",
            "answer": "NaN (Not a Number) is a special numeric value that indicates an invalid or unrepresentable mathematical result, such as dividing 0 by 0."
        },
        {
            "question": "What is the 'class' syntax in JavaScript?",
            "answer": "The 'class' syntax is a more modern way to define object constructors and methods in JavaScript, providing a cleaner syntax for creating objects and dealing with inheritance."
        },
        {
            "question": "What is the difference between 'for' loop and 'for...in' loop in JavaScript?",
            "answer": "A 'for' loop iterates over arrays by index, while 'for...in' iterates over the properties of an object."
        },
        {
            "question": "What is a 'weak reference' in JavaScript?",
            "answer": "A weak reference is a reference to an object that does not prevent it from being garbage collected, which is used in data structures like WeakMap and WeakSet."
        },
        {
            "question": "What is a 'thunk' in JavaScript?",
            "answer": "A thunk is a function that wraps an expression to delay its evaluation, often used in asynchronous programming to ensure certain computations occur only when necessary."
        },
        {
            "question": "What are template literals and how are they different from regular strings?",
            "answer": "Template literals use backticks (`) and allow for embedding expressions using ${expression}, enabling multi-line strings and dynamic content within strings."
        },
        {
            "question": "What is a JavaScript event handler?",
            "answer": "An event handler is a function that handles events like clicks, key presses, or mouse movements, allowing interaction with HTML elements."
        },
        {
            "question": "What is the difference between JavaScript and Node.js?",
            "answer": "JavaScript is a programming language, while Node.js is a runtime environment for executing JavaScript code outside the browser."
        },
        {
            "question": "What is the purpose of the ‘new’ keyword in JavaScript?",
            "answer": "The ‘new’ keyword creates a new instance of a constructor function or a class."
        },
        {
            "question": "What is an asynchronous iterator in JavaScript?",
            "answer": "An asynchronous iterator is an object that can be used to loop over values that are returned asynchronously, typically used with async/await."
        },
        {
            "question": "What are JavaScript promises chained?",
            "answer": "Promises can be chained by returning a new promise from the ‘then()’ method, allowing you to execute multiple asynchronous operations in sequence."
        },
        {
            "question": "What are JavaScript Symbols used for?",
            "answer": "Symbols are unique and immutable values that can be used as object property keys to avoid naming collisions."
        },
        {
            "question": "What is the purpose of ‘Object.create()’ in JavaScript?",
            "answer": "‘Object.create()’ creates a new object with the specified prototype object and properties."
        },
        {
            "question": "What are JavaScript events?",
            "answer": "Events are actions that happen in the system, such as user interactions (click, mouseover, etc.) or system-generated events (load, error)."
        },
        {
            "question": "What is JavaScript’s ‘setTimeout()’ function?",
            "answer": "‘setTimeout()’ is a function that allows you to execute a function after a specified delay."
        },
        {
            "question": "What is the purpose of ‘try...catch’ in JavaScript?",
            "answer": "‘try...catch’ is used to handle exceptions in JavaScript, allowing the code to execute even when an error occurs."
        },
        {
            "question": "What is a JavaScript event listener?",
            "answer": "An event listener is a function that waits for a specific event to occur on an HTML element and reacts accordingly."
        },
        {
            "question": "What is a JavaScript generator function?",
            "answer": "A generator function is a special type of function that can pause its execution using the ‘yield’ keyword and resume later."
        },
        {
            "question": "What is the difference between ‘undefined’ and ‘null’ in JavaScript?",
            "answer": "‘undefined’ means a variable has been declared but not assigned a value, while ‘null’ is an intentional absence of a value."
        },
        {
            "question": "What are JavaScript data structures?",
            "answer": "Common data structures in JavaScript include arrays, objects, sets, maps, and weakmaps, each with unique use cases for storing and organizing data."
        },
        {
            "question": "What are the uses of the ‘this’ keyword in JavaScript?",
            "answer": "‘this’ refers to the object to which a function belongs or the context in which the function is called."
        },
        {
            "question": "What is the difference between ‘map()’ and ‘filter()’ methods in JavaScript?",
            "answer": "‘map()’ transforms each element in an array, while ‘filter()’ returns a new array containing only the elements that satisfy a condition."
        },
        {
            "question": "What is the significance of ‘bind()’, ‘call()’, and ‘apply()’ methods in JavaScript?",
            "answer": "These methods allow you to explicitly set the value of ‘this’ and pass arguments to a function."
        },
        {
            "question": "What is the purpose of the ‘Object.freeze()’ method in JavaScript?",
            "answer": "‘Object.freeze()’ prevents the modification of an object by making it immutable."
        },
        {
            "question": "What is the event loop?",
            "answer": "The event loop is a mechanism that continuously checks the message queue to execute tasks asynchronously. It ensures that non-blocking code, such as setTimeout or AJAX calls, is executed when the call stack is clear."
        },
        {
            "question": "What is the difference between 'let', 'const', and 'var'?",
            "answer": "'let' and 'const' are block-scoped, while 'var' is function-scoped. 'let' allows reassignment, 'const' does not allow reassignment, and 'var' can be redeclared and has a hoisting behavior."
        },
        {
            "question": "What is hoisting in JavaScript?",
            "answer": "Hoisting is the JavaScript behavior where variable and function declarations are moved to the top of their containing scope during the compilation phase, but the assignment remains in the original position."
        },
        {
            "question": "What is the difference between 'forEach()' and 'map()'?",
            "answer": "'forEach()' iterates over an array and applies a function to each element but returns 'undefined', while 'map()' creates a new array populated with the results of calling a provided function on each element of the original array."
        },
        {
            "question": "What are higher-order functions in JavaScript?",
            "answer": "Higher-order functions are functions that take other functions as arguments or return a function as a result. Examples include map(), filter(), and reduce()."
        },
        {
            "question": "What are the advantages of using 'arrow functions'?",
            "answer": "Arrow functions are more concise than traditional functions and inherit the 'this' value from their surrounding context (lexical scoping), making them useful in certain situations like event handlers."
        },
        {
            "question": "What is 'this' in JavaScript and how does it work?",
            "answer": "'this' refers to the context in which a function is called, and it can vary depending on how a function is invoked. In global scope, it refers to the global object, but in an object method, it refers to the object itself."
        },
        {
            "question": "What are JavaScript Promises and how do they work?",
            "answer": "A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation. It has three states: pending, resolved (fulfilled), or rejected. Promises provide methods like 'then()', 'catch()', and 'finally()' for handling asynchronous results."
        },
        {
            "question": "What is the purpose of 'bind()' method in JavaScript?",
            "answer": "'bind()' creates a new function that, when called, has its 'this' keyword set to the provided value, and prepends any provided arguments to the function call."
        },
        {
            "question": "What is the 'typeof' operator in JavaScript?",
            "answer": "'typeof' is used to determine the type of a given variable or expression, returning a string that indicates its type, such as 'string', 'number', 'object', etc."
        },
        {
            "question": "What are JavaScript decorators?",
            "answer": "Decorators are special functions that can be used to modify or enhance the behavior of classes and class methods. They are proposed for future versions of JavaScript and are currently available in some transpilers like Babel."
        },
        {
            "question": "What is a closure in JavaScript and give an example?",
            "answer": "A closure is a function that retains access to variables from its lexical scope, even after the outer function has finished execution. For example, a function inside another function that still has access to the outer function’s variables."
        },
        {
            "question": "What are the differences between 'async' and 'await' in JavaScript?",
            "answer": "'async' is used to define a function as asynchronous, returning a promise, and 'await' is used within an 'async' function to pause the function’s execution until the promise resolves."
        },
        {
            "question": "What is 'throttling' and 'debouncing' in JavaScript?",
            "answer": "Throttling limits the rate at which a function is invoked, ensuring it is only called once within a specified time period. Debouncing ensures that a function is only called after a certain period of inactivity."
        },
        {
            "question": "What is the difference between '==', '===' and 'Object.is()'?",
            "answer": "'==' performs type coercion, '===' checks both value and type equality, and 'Object.is()' checks strict equality without type conversion, handling edge cases like NaN and -0."
        },
        {
            "question": "What is the purpose of the 'new' keyword in JavaScript?",
            "answer": "The 'new' keyword is used to create a new instance of a user-defined object type or class. It allocates memory for the object, sets the object's 'prototype' to the constructor function’s prototype, and returns the new object."
        },
        {
            "question": "What is the difference between 'shallow copy' and 'deep copy'?",
            "answer": "A shallow copy copies only the first level of an object, meaning nested objects are shared between the original and the copy, while a deep copy recursively copies all levels, creating entirely separate objects."
        },
        {
            "question": "How do you handle errors in JavaScript?",
            "answer": "Errors in JavaScript can be handled using 'try...catch' blocks, where code is executed inside the 'try' block, and any errors are caught by the 'catch' block. Additionally, custom errors can be thrown using 'throw'."
        },
        {
            "question": "What is a generator function in JavaScript?",
            "answer": "A generator function is defined using the 'function*' syntax and allows you to pause and resume the function’s execution. It uses the 'yield' keyword to yield values one at a time."
        },
        {
            "question": "What is the purpose of the 'super' keyword in JavaScript?",
            "answer": "The 'super' keyword is used to call functions on an object's parent class. It is commonly used in classes to call the constructor of the parent class or to access methods in the parent class."
        },
        {
            "question": "What is a 'weakmap' in JavaScript?",
            "answer": "A 'WeakMap' is a collection of key-value pairs where the keys are objects and the values can be any value. The keys in a WeakMap are weakly referenced, meaning they do not prevent garbage collection if there are no other references to the key."
        },
        {
            "question": "What are the different ways to define a function in JavaScript?",
            "answer": "Functions in JavaScript can be defined using function declarations, function expressions, arrow functions, and methods inside objects or classes."
        },
        {
            "question": "What are JavaScript’s primitive data types?",
            "answer": "The primitive data types in JavaScript are: String, Number, Boolean, Null, Undefined, Symbol, and BigInt."
        },
        {
            "question": "What is an anonymous function?",
            "answer": "An anonymous function is a function that is defined without a name. It is often used as an argument to higher-order functions."
        },
        {
            "question": "What is the difference between 'call' and 'apply' methods?",
            "answer": "'call' and 'apply' are both used to invoke functions with a specified 'this' value, but 'call' takes arguments individually, while 'apply' takes arguments as an array."
        },
        {
            "question": "What are closures in JavaScript?",
            "answer": "A closure is a function that retains access to the variables from its lexical scope, even after the outer function has finished execution."
        },
        {
            "question": "What is the difference between 'Array.push()' and 'Array.unshift()'?",
            "answer": "'push()' adds an element to the end of an array, while 'unshift()' adds an element to the beginning of an array."
        },
        {
            "question": "What is 'JSON.parse()' and 'JSON.stringify()' used for?",
            "answer": "'JSON.parse()' converts a JSON string into a JavaScript object, while 'JSON.stringify()' converts a JavaScript object into a JSON string."
        },
        {
            "question": "What is an ES6 feature in JavaScript?",
            "answer": "ES6 (ECMAScript 2015) introduced several features, such as arrow functions, classes, template literals, let/const, and destructuring assignments."
        },
        {
            "question": "What is the purpose of 'debugger' in JavaScript?",
            "answer": "'debugger' is a keyword used to pause code execution in a browser's developer tools for debugging purposes."
        },
        {
            "question": "What is the purpose of the 'eval()' function?",
            "answer": "'eval()' executes a string of JavaScript code in the current scope, but it is generally avoided due to security risks and performance issues."
        },
        {
            "question": "What is the difference between a deep copy and a shallow copy?",
            "answer": "A shallow copy copies the first level of an object, while a deep copy copies all levels recursively, including nested objects."
        },
        {
            "question": "What is the difference between 'undefined' and 'undeclared' variables?",
            "answer": "'undefined' refers to a variable that has been declared but not assigned a value, while 'undeclared' refers to a variable that has not been declared at all."
        },
        {
            "question": "What is the difference between '==' and '===' operators?",
            "answer": "'==' compares values after performing type coercion, while '===' compares both value and type without performing type coercion."
        },
        {
            "question": "What is the purpose of 'use strict'?",
            "answer": "'use strict' enables stricter parsing and error handling in JavaScript to avoid some silent errors and unsafe actions."
        },
        {
            "question": "What is the difference between 'null' and 'undefined' in JavaScript?",
            "answer": "'null' is an assignment value representing the intentional absence of any object value, while 'undefined' is the default value of variables that have been declared but not assigned a value."
        },
        {
            "question": "What is the 'Promise.all()' method in JavaScript?",
            "answer": "The 'Promise.all()' method takes an array of promises and returns a single promise that resolves when all the input promises have resolved or rejects if any of the promises reject."
        },
        {
            "question": "What is the 'reduce()' method in JavaScript?",
            "answer": "The 'reduce()' method is used to apply a function to an accumulator and each element in the array (from left to right) to reduce it to a single value, such as summing an array of numbers."
        },
        {
            "question": "What is a 'singleton' pattern in JavaScript?",
            "answer": "The singleton pattern is a design pattern that restricts a class to only one instance, ensuring a global access point to that instance. In JavaScript, it can be implemented using closures or by using a class."
        },
        {
            "question": "What is the difference between 'slice()' and 'splice()' in JavaScript?",
            "answer": "'slice()' is used to create a shallow copy of a portion of an array, without modifying the original array. 'splice()' modifies the original array by removing or adding elements to it."
        },
        {
            "question": "What is the 'event delegation' pattern in JavaScript?",
            "answer": "Event delegation is a technique where you attach a single event listener to a parent element instead of individual child elements. The event is then propagated from the child element to the parent, reducing the number of listeners."
        },
        {
            "question": "What is the 'Module' pattern in JavaScript?",
            "answer": "The module pattern is a design pattern that allows you to encapsulate private data and functions while exposing a public API. This is commonly done using closures and immediately invoked function expressions (IIFE)."
        },
        {
            "question": "What are 'Web Workers' in JavaScript?",
            "answer": "Web Workers allow for the execution of JavaScript in the background, enabling parallel processing without blocking the main thread. They are useful for performing resource-intensive computations."
        },
        {
            "question": "What is a 'proxy' in JavaScript?",
            "answer": "A Proxy is an object that wraps another object and allows you to intercept and customize operations performed on that object, such as getting or setting properties, calling functions, etc."
        },
        {
            "question": "What is 'localStorage' and 'sessionStorage' in JavaScript?",
            "answer": "'localStorage' and 'sessionStorage' are both used for storing data in the web browser. 'localStorage' stores data persistently until it is explicitly deleted, while 'sessionStorage' stores data for the duration of a page session."
        },
        {
            "question": "What is the difference between 'Object.create()' and 'new' in JavaScript?",
            "answer": "'Object.create()' creates a new object with a specified prototype, whereas 'new' creates an instance of a constructor function, linking the object to the constructor's prototype."
        },
        {
            "question": "What is the 'apply()' method in JavaScript?",
            "answer": "'apply()' is a method that calls a function with a specified 'this' value and arguments passed as an array (or an array-like object). It is often used when you want to invoke a function with dynamic arguments."
        },
        {
            "question": "What are 'set' and 'map' objects in JavaScript?",
            "answer": "'Set' is a collection of unique values (no duplicates), while 'Map' is a collection of key-value pairs where keys can be any value (not just strings) and can store both primitive and object values."
        },
        {
            "question": "What is a 'callback hell' and how do you avoid it?",
            "answer": "Callback hell refers to the nested and often hard-to-read structure of multiple callback functions in asynchronous programming. It can be avoided by using promises, async/await, or modularizing the code into smaller functions."
        },
        {
            "question": "What is the 'EventEmitter' class in Node.js?",
            "answer": "The 'EventEmitter' class is used to handle events in Node.js. It allows an object to emit events and allows other objects to listen and respond to those events."
        },
        {
            "question": "What is the purpose of the 'Reflect' API in JavaScript?",
            "answer": "The 'Reflect' API provides methods to interact with objects in a more declarative manner. It is often used for operations such as defining properties, getting values, or calling methods, and offers better error handling than traditional techniques."
        },
        {
            "question": "What is a 'deep freeze' in JavaScript?",
            "answer": "A 'deep freeze' is a technique used to make an object and all its nested objects immutable. This ensures that the object’s properties cannot be modified or added after freezing."
        },
        {
            "question": "What is the 'Rest' parameter in JavaScript?",
            "answer": "The 'Rest' parameter is used to collect all remaining arguments into a single array. It is defined by placing '...' before a parameter in a function definition."
        },
        {
            "question": "What is the 'spread' operator?",
            "answer": "The 'spread' operator is used to unpack values from arrays or objects into individual elements. It is often used to combine or copy arrays and objects."
        },
        {
            "question": "What is 'event bubbling' and 'event capturing'?",
            "answer": "Event bubbling refers to the process where an event starts at the target element and propagates upward through the DOM tree. Event capturing (or trickling) is the opposite, where the event starts from the root and goes down to the target element."
        },
        {
            "question": "What are 'getter' and 'setter' methods in JavaScript?",
            "answer": "Getter and setter methods allow you to define custom behavior for getting and setting object properties. A getter method returns the value of a property, while a setter method sets the value of a property."
        },
        {
            "question": "What is a 'throttle' function in JavaScript?",
            "answer": "A throttle function ensures that a function is only called once in a specified period, no matter how frequently the event is triggered. It is useful for rate-limiting function execution, such as during scrolling or resizing."
        },
        {
            "question": "What is 'async/await' in JavaScript?",
            "answer": "The 'async/await' syntax provides a way to write asynchronous code in a synchronous-like manner. The 'async' keyword is used to define a function that returns a promise, and 'await' is used to pause execution until the promise resolves."
        },
        {
            "question": "What is the 'setImmediate' method in Node.js?",
            "answer": "'setImmediate' is a method in Node.js that schedules a function to be executed after the current event loop cycle, which means it runs after all I/O events in the event queue have been processed."
        },
        {
            "question": "What is the 'set' data structure?",
            "answer": "A 'set' is a collection of unique values in JavaScript. It does not allow duplicates and is typically used when you need to store non-repetitive items. It also provides methods like 'add()', 'has()', and 'delete()'."
        },
        {
            "question": "What is 'setTimeout()' vs 'setInterval()' in JavaScript?",
            "answer": "'setTimeout()' schedules a function to execute once after a specified delay, while 'setInterval()' repeatedly executes a function at specified intervals. Both return a unique identifier for clearing the timer."
        },
        {
            "question": "What is the 'call stack' in JavaScript?",
            "answer": "The call stack is a mechanism that keeps track of the function calls in a program. When a function is invoked, it is added to the call stack, and when it finishes, it is removed. It follows a Last In, First Out (LIFO) order."
        },
        {
            "question": "What is 'IIFE' (Immediately Invoked Function Expression) in JavaScript?",
            "answer": "An IIFE is a function that is defined and invoked immediately after its creation. It is often used to create a private scope for variables, avoiding polluting the global namespace."
        },
        {
            "question": "What is 'destructuring' in JavaScript?",
            "answer": "Destructuring is a syntax that allows unpacking values from arrays or properties from objects into distinct variables. It can simplify the process of accessing and assigning values from complex structures."
        },
        {
            "question": "What is 'memoization' in JavaScript?",
            "answer": "Memoization is an optimization technique where a function’s results are cached based on its inputs, so subsequent calls with the same arguments can return the cached result instead of recomputing it."
        },
        {
            "question": "What is a 'currying' function in JavaScript?",
            "answer": "Currying is a technique where a function with multiple arguments is transformed into a series of functions, each taking one argument and returning a new function to handle the next argument."
        },
        {
            "question": "What is 'destructuring assignment' and how is it used in JavaScript?",
            "answer": "Destructuring assignment allows you to extract values from arrays or objects and assign them to variables. It simplifies syntax for accessing multiple properties or elements from a structure."
        },
        {
            "question": "What is DOM?",
            "answer": "DOM (Document Object Model) is a programming interface for web documents. It represents the structure of a web page as a tree of objects where each object corresponds to part of the page (elements, attributes, text). DOM allows programming languages like JavaScript to manipulate the structure, style, and content of the page."
        },
        {
            "question": "What is BOM?",
            "answer": "BOM (Browser Object Model) is a model that provides interaction with the web browser itself. It allows access to features such as the browser window, history, location, screen size, and more. Unlike the DOM, which is focused on the document, BOM deals with the environment outside of the document."
        },
        {
            "question": "What is the difference between function declaration and function expression?",
            "answer": "A function declaration defines a function with a name and can be called before it appears in the code due to hoisting. A function expression, on the other hand, creates a function as part of an expression and cannot be called before its definition, as it is not hoisted. Function expressions can be anonymous or named."
        },
        {
            "question": "What is the output of `console.log(typeof NaN);` in JavaScript?",
            "answer": "'number'. Although `NaN` stands for 'Not-a-Number', it is technically of the 'number' type in JavaScript."
        },
        {
            "question": "What does the `typeof` operator return when used on an array in JavaScript?",
            "answer": "'object'. In JavaScript, arrays are technically objects, and `typeof` will return 'object' when applied to an array."
        },
        {
            "question": "How do you remove the last element of an array in JavaScript?",
            "answer": "You can use the `pop()` method to remove the last element from an array."
        },
        {
            "question": "What is the purpose of `Array.isArray()` in JavaScript?",
            "answer": "`Array.isArray()` checks if a given value is an array and returns `true` if it is, and `false` otherwise."
        }
    ],
    "react-native": [
        {
            "question": "What is React Native?",
            "answer": "React Native is an open-source framework developed by Facebook for building mobile applications using JavaScript and React. It allows developers to write mobile apps for iOS and Android platforms using a single codebase, leveraging native components and APIs for a more native-like performance."
        },
        {
            "question": "List some benefits of using React Native for building mobile apps.",
            "answer": "Some benefits of using React Native include faster development with a shared codebase, native performance, access to native features via third-party libraries, large community support, and the ability to use React's component-based architecture, which simplifies UI development and state management."
        },
        {
            "question": "Why do we use curly braces while importing some libraries?",
            "answer": "Curly braces `{}` are used to import specific components, functions, or variables from a module or library in JavaScript (including React Native). When you use curly braces, you're importing named exports from the module, rather than the entire module or default export."
        },
        {
            "question": "What are the advantages of hybrid apps over native apps?",
            "answer": "Hybrid apps offer advantages such as faster development with a single codebase for multiple platforms, lower development costs, and easier maintenance. They are typically easier to update and deploy across multiple platforms, unlike native apps, which require separate codebases for each platform."
        },
        {
            "question": "What are hybrid apps?",
            "answer": "Hybrid apps are mobile applications built using web technologies such as HTML, CSS, and JavaScript, but packaged inside a native container, allowing them to run on multiple platforms (iOS, Android) with a single codebase. They can access native device features using plugins or APIs."
        },
        {
            "question": "What are native apps?",
            "answer": "Native apps are applications built specifically for a single platform (iOS or Android) using platform-specific programming languages like Swift/Objective-C for iOS or Java/Kotlin for Android. They offer better performance and access to device features but require separate development for each platform."
        },
        {
            "question": "What are the types of data that control a component?",
            "answer": "The types of data that control a component in React (and React Native) are props and state. `Props` are used to pass data from parent components to child components, while `state` holds data that can change over time and controls the behavior and rendering of the component."
        },
        {
            "question": "What determines the size of a component and what are the ways?",
            "answer": "The size of a component in React (and React Native) is determined by its content, the styling applied (e.g., width, height, padding, margin), and the parent container’s layout properties. Layout properties like flexbox, fixed sizes, or dynamic content can all influence the size of the component. You can use flexbox properties, `width`, `height`, and `flex` to control the component's size."
        },
        {
            "question": "What are some ways of styling a React Native component?",
            "answer": "Some ways of styling a React Native component include using `StyleSheet.create()` to define styles, inline styles with the `style` prop, or using third-party libraries like `styled-components` or `react-native-paper` for more advanced styling solutions."
        },
        {
            "question": "What does the gesture responder system do?",
            "answer": "The gesture responder system in React Native is responsible for handling touch events, allowing components to respond to gestures like taps, drags, and swipes. It ensures that only one component responds to an interaction at a time and provides the necessary callbacks to track and control gesture events."
        },
        {
            "question": "What are Refs used for in React Native?",
            "answer": "Refs in React Native are used to reference and interact with DOM or native components directly. They allow you to get a reference to a specific component, such as a text input or button, and perform actions like focusing, measuring, or animating the component without re-rendering it."
        },
        {
            "question": "How do you dismiss the keyboard in React Native?",
            "answer": "To dismiss the keyboard in React Native, you can use `Keyboard.dismiss()`. This method will hide the keyboard when called, typically after a user submits a form or taps outside of an input field."
        },
        {
            "question": "What are the advantages of native apps over hybrid apps?",
            "answer": "Native apps offer several advantages over hybrid apps, including better performance, smoother user experience, and deeper integration with platform-specific APIs and device features. Native apps are typically faster because they are optimized for the target platform and do not rely on web technologies. They also have better access to native UI components and can provide more advanced, platform-specific functionality."
        },
        {
            "question": "When would you use ScrollView over FlatList or vice-versa?",
            "answer": "Use `ScrollView` when you need to display a small number of items that do not require optimization for memory usage, such as when the list's content is known to be small and static. Use `FlatList` when rendering a large or dynamic list of items, as it is optimized for performance by only rendering the items that are currently visible on the screen."
        },
        {
            "question": "Tell us some options of storing persisting data in a React Native app?",
            "answer": "In React Native, you can use options like `AsyncStorage`, `SQLite`, `Realm`, `WatermelonDB`, and `React Native MMKV` for persisting data. `AsyncStorage` is commonly used for storing simple key-value pairs, while databases like `SQLite` and `Realm` are used for more complex data storage needs."
        },
        {
            "question": "What is JSX?",
            "answer": "JSX (JavaScript XML) is a syntax extension for JavaScript used in React and React Native. It allows you to write HTML-like code inside JavaScript, which is then compiled into regular JavaScript function calls that render the user interface. JSX makes it easier to visualize and structure the components in a declarative manner."
        },
        {
            "question": "How is React Native different from ReactJS?",
            "answer": "React Native is a framework for building mobile applications for iOS and Android, while ReactJS is a library used for building web applications. React Native uses native components (e.g., `View`, `Text`, `Image`), while ReactJS uses HTML elements (e.g., `div`, `span`, `img`) for rendering the UI. React Native compiles down to native code, while ReactJS runs in a web browser."
        },
        {
            "question": "What are props in React Native?",
            "answer": "Props (short for properties) in React Native are read-only inputs passed to components from their parent. They allow components to receive dynamic data and configuration from the parent and use that data to render content or influence behavior. Props are immutable, meaning they cannot be changed by the child component."
        },
        {
            "question": "What is the use of FlatList?",
            "answer": "`FlatList` is a component in React Native used for rendering large lists of data in an optimized way. It only renders items that are currently visible on the screen, improving performance when displaying long or dynamic lists. `FlatList` supports features like item separators, pull-to-refresh, and infinite scrolling."
        },
        {
            "question": "How are Hot Reloading and Live Reloading in React Native different?",
            "answer": "Hot Reloading in React Native allows you to instantly see the changes you make to the code without losing the state of your app. Live Reloading, on the other hand, reloads the entire app every time you make changes to the code, causing the app to lose its current state. Hot Reloading is generally faster and more efficient than Live Reloading."
        },
        {
            "question": "Explain the use of Flexbox in React Native?",
            "answer": "Flexbox is a layout model used in React Native to create flexible and responsive layouts. It helps arrange components in a row or column direction and allows for easy alignment, distribution of space, and responsiveness. Flexbox simplifies complex layout tasks by offering properties like `justifyContent`, `alignItems`, and `flexDirection`."
        },
        {
            "question": "How are props and state different?",
            "answer": "Props (short for properties) are immutable inputs passed to a component from its parent, while state is mutable data managed within the component itself. Props are used to pass data down the component tree, whereas state holds data that may change over time and is used to trigger re-renders of the component."
        },
        {
            "question": "What does TouchableHighlight do and when do you use it?",
            "answer": "`TouchableHighlight` is a component in React Native that responds to touch events and provides feedback by highlighting the component when pressed. It is used to create interactive elements like buttons or clickable areas, especially when you want to change the appearance (e.g., change opacity or background color) when the user touches the component."
        },
        {
            "question": "What is State in React Native?",
            "answer": "State in React Native is a mutable object that holds data or information that may change over time. It is used to store values that affect how a component behaves and renders. State can be updated using `setState()` and triggers a re-render of the component whenever it changes."
        },
        {
            "question": "What are Touchable Interactions in React Native?",
            "answer": "Touchable Interactions in React Native refer to components that can respond to user touch events, such as taps, presses, or swipes. Components like `TouchableOpacity`, `TouchableHighlight`, `TouchableWithoutFeedback`, and `TouchableNativeFeedback` allow developers to handle interactions with UI elements, providing feedback or triggering actions when the user touches the component."
        },
        {
            "question": "What is 'Fast Refresh'?",
            "answer": "'Fast Refresh' is a feature in React Native that allows developers to see changes in the app instantly while preserving the component's state. It enables quick iterations during development by reloading only the modified components, resulting in a smoother and faster development experience compared to traditional reloading."
        },
        {
            "question": "What is flex dimension and how is it different from fixed dimension?",
            "answer": "A flex dimension in React Native refers to a layout property where the size of an element is determined by the available space and its relationship with other elements, using Flexbox. Fixed dimensions, on the other hand, have a set value (like pixels or a fixed percentage) for width and height, which does not change based on the container's size or other elements."
        },
        {
            "question": "How do you style a component in React Native?",
            "answer": "In React Native, you style components using the `StyleSheet.create()` method to define styles in a JavaScript object. You can then apply these styles to components using the `style` prop. Inline styles are also possible, but using `StyleSheet.create()` is more efficient and helps improve performance."
        },
        {
            "question": "How do you perform logging in React Native?",
            "answer": "In React Native, logging can be performed using the `console.log()` function, just like in JavaScript. This is typically used to print debug information, variables, or messages to the console during development. You can also use third-party libraries like `react-native-debugger` for more advanced logging and debugging features."
        },
        {
            "question": "What are some features of Fast Refresh?",
            "answer": "Some features of Fast Refresh include preserving the component state, allowing for real-time feedback during code changes, automatic component reloading on code modifications, and supporting both function and class components. It improves the developer experience by minimizing reload time and reducing UI glitches."
        },
        {
            "question": "What is AppRegistry? Why is it required early in the 'require' sequence?",
            "answer": "AppRegistry in React Native is the entry point for running an app. It registers the root component of the application and is required early in the 'require' sequence because it ensures that the app starts correctly by linking the JavaScript code to the native environment. It is essential for the app's lifecycle to function properly on both iOS and Android platforms."
        },
        {
            "question": "What does StyleSheet.create do and why is it useful?",
            "answer": "`StyleSheet.create` in React Native is used to define a set of styles in a structured way. It returns an object that contains the styles, which can then be applied to components. It is useful because it optimizes the performance of the app by ensuring that styles are processed once and not recreated on each render, leading to faster rendering and better memory usage."
        },
        {
            "question": "How do you re-render a FlatList?",
            "answer": "To re-render a `FlatList`, you can modify the data it is displaying (e.g., by changing the data array or adding/removing items) and pass the updated data to the `FlatList` through the `data` prop. You can also use the `extraData` prop to trigger re-renders when non-data-related changes occur, such as changes in state or props."
        },
        {
            "question": "How is flexbox different in React Native and the browser?",
            "answer": "While Flexbox works similarly in React Native and the browser, the key difference is in how they handle certain layout scenarios. In React Native, Flexbox is used to build responsive mobile UIs and supports properties like `flex`, `justifyContent`, and `alignItems`. However, in the browser, Flexbox is used to manage layouts on web pages and might have some differences in behavior due to CSS quirks, such as browser-specific rendering and styling rules."
        },
        {
            "question": "What happens if you edit modules with exports that are not React components in Fast Refresh?",
            "answer": "In Fast Refresh, if you edit modules that export non-React components, such as plain JavaScript functions or utility modules, the changes will be applied without affecting the rest of the app. Fast Refresh will reload the modified module without disrupting the app's state, ensuring that the new code is used without requiring a full app reload."
        },
        {
            "question": "What is the use of ScrollView component?",
            "answer": "The `ScrollView` component in React Native is used to create scrollable areas within an app. It is useful for displaying content that exceeds the screen size, allowing users to scroll vertically or horizontally. `ScrollView` is typically used when the content is dynamic or has a fixed height but needs to be scrollable."
        },
        {
            "question": "In Fast Refresh, what will happen if you edit files imported by modules outside of the React tree?",
            "answer": "In Fast Refresh, if you edit files that are imported by modules outside of the React tree, such as utility modules or non-UI-related code, only the affected modules will be updated without triggering a full reload of the React components. This helps maintain the current app state while ensuring that non-UI changes are reflected in the app without re-rendering the entire UI."
        },
        {
            "question": "What are some best practices to consider for an action?",
            "answer": "Some best practices for actions include making actions pure functions (not modifying state directly), giving meaningful names to actions, maintaining consistency in action types, and using action creators to avoid hardcoding strings. Additionally, keep actions simple and focused, with one action per function, and handle asynchronous actions using middleware like Redux Thunk or Redux Saga."
        },
        {
            "question": "What is Lifting State Up?",
            "answer": "Lifting State Up is a pattern in React where state is moved from a child component to its parent so that multiple child components can share and update the state. This allows for centralized management of state and ensures that different parts of the application can communicate or react to changes in a unified way."
        },
        {
            "question": "What happens if you edit a module that only exports React components in Fast Refresh?",
            "answer": "If you edit a module that only exports React components in Fast Refresh, the module will be updated, and the changes will be reflected in the app without a full reload. The state of the component will be preserved, and only the modified component will be re-rendered, ensuring a faster development process."
        },
        {
            "question": "What is 'Autolinking' in React Native?",
            "answer": "Autolinking is a feature in React Native that automatically links native dependencies to the project without requiring manual linking. When installing a package with native code, Autolinking detects the necessary configurations and links the corresponding native modules, reducing the need for manual setup steps."
        },
        {
            "question": "What is View and how important is it?",
            "answer": "In React Native, `View` is a core component used to create container elements that can hold other components. It is essential for building the layout structure and can be styled with Flexbox properties. `View` serves as the building block for organizing and positioning other components in the user interface."
        },
        {
            "question": "What are some limitations of using react-native-cli for instantiating a project?",
            "answer": "Some limitations of using `react-native-cli` include the need for manual linking of native modules, less flexibility in managing dependencies, and fewer built-in tools for managing the project. Also, the setup process can be more error-prone compared to using `Expo`, which simplifies some tasks. `react-native-cli` requires more configuration and setup for things like Android and iOS builds."
        },
        {
            "question": "What is AsyncStorage and how do you use it?",
            "answer": "AsyncStorage is a simple, asynchronous, unencrypted, persistent key-value storage system in React Native. It is used for storing small pieces of data such as user preferences or session information. You can use it by importing `@react-native-async-storage/async-storage`, then using methods like `setItem()`, `getItem()`, and `removeItem()` to store and retrieve data."
        },
        {
            "question": "What are the features of Container/Smart components?",
            "answer": "Container or Smart components are responsible for handling the application's logic and managing state. They often pass data and callbacks down to presentational or dumb components. Features include managing data fetching, state changes, and providing the necessary logic to the UI components, ensuring that UI components remain focused on rendering and don't handle complex logic."
        },
        {
            "question": "Does React Native compile JavaScript into Java for Android?",
            "answer": "No, React Native does not compile JavaScript into Java for Android. Instead, React Native uses a bridge to communicate between JavaScript code and the native Android components written in Java. The JavaScript code is executed by a JavaScript engine (such as JavaScriptCore), and the bridge is used to interact with native code."
        },
        {
            "question": "What are some advantages of Component Driven Development?",
            "answer": "Component Driven Development focuses on building UI components in isolation, which leads to reusable, maintainable, and testable components. It encourages modularity, improves collaboration between teams, enhances code consistency, and simplifies UI testing. It also allows for easier updates and optimizations as individual components can be modified independently of the rest of the application."
        },
        {
            "question": "How would you implement animations on events?",
            "answer": "In React Native, animations can be implemented using the `Animated` API. To implement animations on events, such as button clicks or scroll actions, you can attach event handlers to components (e.g., using `onPress` for a button). Within the event handler, you trigger animation changes using methods like `Animated.timing()` or `Animated.spring()` to animate properties such as position, opacity, or scale."
        },
        {
            "question": "State the lifecycle of Gesture Responder System?",
            "answer": "The Gesture Responder System in React Native follows a lifecycle with the following phases: 1) `onStartShouldSetResponder`: Determines if the component should become the responder. 2) `onMoveShouldSetResponder`: Determines if the component should become the responder when a gesture moves. 3) `onResponderGrant`: Fired when the component is granted responder status. 4) `onResponderMove`: Fired as the gesture moves. 5) `onResponderRelease`: Fired when the gesture is released. 6) `onResponderTerminate`: Fired when another responder takes over."
        },
        {
            "question": "What is Component Driven Development (CDD)?",
            "answer": "Component Driven Development (CDD) is an approach where development is focused on building UI components in isolation before integrating them into the application. It encourages reusability, modularity, and maintainability by designing self-contained, reusable components that can be independently tested and iterated upon, streamlining collaboration and improving development efficiency."
        },
        {
            "question": "What are Container/Smart components?",
            "answer": "Container or Smart components are components responsible for handling the logic and state of the application. They manage data fetching, state updates, and pass down props to presentational components. These components do not contain UI logic but instead manage how the UI behaves based on state changes."
        },
        {
            "question": "What are Presentational/Dumb Components?",
            "answer": "Presentational or Dumb components are primarily responsible for rendering the UI. They receive data and callbacks as props and focus solely on the display aspect of the app. These components are typically stateless and do not contain any business logic or state management."
        },
        {
            "question": "How many threads run in a React Native app?",
            "answer": "A React Native app typically runs in two main threads: the JavaScript thread, where JavaScript code is executed, and the Native thread, which handles interactions with the native components and UI. Additionally, React Native uses a bridge to allow communication between the JavaScript thread and native code, enabling asynchronous interactions."
        },
        {
            "question": "What does React Native Packager do in React Native?",
            "answer": "The React Native Packager is responsible for bundling JavaScript code and assets, transforming and optimizing them into a format that can be run by the mobile device. It serves the JavaScript bundle to the React Native app and handles live reloading, asset loading, and the transformation of files into the appropriate format for execution on mobile devices."
        },
        {
            "question": "Differentiate ScrollView and FlatList?",
            "answer": "The primary difference between `ScrollView` and `FlatList` is that `ScrollView` renders all its child components at once, regardless of their visibility on the screen, which can be inefficient for large lists. In contrast, `FlatList` only renders the items that are currently visible on the screen, improving performance for large datasets by lazily loading items as needed."
        },
        {
            "question": "What are features of Presentational/Dumb Components?",
            "answer": "Presentational/Dumb components focus purely on the UI and rendering. They receive data and functions as props and do not manage state or logic. They are reusable, independent of the app's state, and are easy to test because they don't contain complex business logic. Their only concern is how the data is presented on the screen."
        },
        {
            "question": "Are libraries such as TypeScript that compile to JavaScript compatible with React Native?",
            "answer": "Yes, libraries such as TypeScript are compatible with React Native. TypeScript is a superset of JavaScript that provides static typing. React Native has built-in support for TypeScript, allowing developers to use TypeScript for type safety while still compiling down to JavaScript, which React Native understands and executes."
        },
        {
            "question": "What is Higher Order Component (HOC)?",
            "answer": "A Higher Order Component (HOC) is a function in React that takes a component and returns a new component with additional props or functionality. HOCs are used for reusing component logic, enhancing components with extra behavior, and adding cross-cutting concerns like authentication, styling, or data fetching without modifying the original component."
        },
        {
            "question": "What JavaScript engine does React Native use?",
            "answer": "React Native uses JavaScriptCore (JSC), which is the JavaScript engine developed by Apple and used in iOS. For Android, React Native typically uses JSC as well, though there are alternatives like Hermes, a more optimized JavaScript engine designed by Facebook for improved performance and startup time."
        },
        {
            "question": "What are the disadvantages of StyleSheet.create?",
            "answer": "The disadvantages of `StyleSheet.create` include the fact that it requires the styles to be defined ahead of time and can be less flexible for dynamic styling compared to inline styles. Additionally, it may introduce additional complexity when managing conditional or runtime styles, and its use can lead to unnecessary rerendering in certain edge cases."
        },
        {
            "question": "How is InteractionManager important?",
            "answer": "The `InteractionManager` in React Native is used to delay the execution of non-urgent tasks until after interactions and animations are complete. This helps prevent UI jank and performance issues by ensuring that tasks like data fetching, network requests, or complex operations don't interfere with smooth user interactions."
        },
        {
            "question": "How does the Fabric architecture work?",
            "answer": "The Fabric architecture in React Native introduces a new rendering system for handling the UI layer. It decouples the JavaScript thread from the UI thread and introduces a more efficient, asynchronous approach to rendering components. Fabric improves performance by enabling concurrent rendering, reducing thread-blocking, and providing better support for background tasks and animations."
        },
        {
            "question": "What are some benefits of Container-Presentational pattern?",
            "answer": "The Container-Presentational pattern promotes the separation of concerns, with Container components managing the state and logic, and Presentational components focusing purely on rendering UI. Benefits include improved code reusability, better maintainability, easier testing, and clearer component responsibilities. It also enables easier refactoring and collaboration across teams."
        },
        {
            "question": "What is InteractionManager and how is it used?",
            "answer": "The `InteractionManager` is a utility in React Native used to schedule tasks to run after all interactions and animations are complete. It's useful for deferring non-urgent tasks like network requests or data fetching to avoid blocking the UI and to ensure smooth, responsive user interactions. You can use it by calling `InteractionManager.runAfterInteractions()`."
        },
        {
            "question": "What is Fabric in React Native?",
            "answer": "Fabric is the new architecture introduced in React Native to improve the performance and scalability of the framework. It enables an asynchronous rendering model and more efficient updates between the JavaScript and native layers. Fabric aims to address limitations in the current rendering system by optimizing how components are rendered and updated on the UI."
        },
        {
            "question": "Does React Native have a Virtual DOM?",
            "answer": "No, React Native does not use a Virtual DOM like React for web. Instead of the Virtual DOM, React Native directly interacts with native views through a bridge, using the native rendering APIs for iOS and Android. The components in React Native are mapped to native views instead of being rendered to a Virtual DOM first."
        }
    ],
    "nextjs": [
        {
            "question": "What is Next.js, and why is it used?",
            "answer": "Next.js is a React-based framework for building server-side rendered (SSR) and statically generated (SSG) web applications. It simplifies development by providing features like file-based routing, SSR, SSG, API routes, and built-in CSS support, making it ideal for modern web applications."
        },
        {
            "question": "How does Next.js differ from React?",
            "answer": "React is a library for building UI components, while Next.js is a framework that extends React to include server-side rendering, static site generation, file-based routing, and API capabilities."
        },
        {
            "question": "How does Next.js handle client-side navigation, and what role does the router play?",
            "answer": "Next.js uses the Link component for client-side navigation, leveraging the router object for programmatic navigation and state management"
        },
        {
            "question": "Explain the concept of Incremental Static Regeneration (ISR) in Next.js and how it improves performance and SEO.",
            "answer": "Incremental Static Regeneration (ISR) in Next.js allows you to update static content after the site has been built and deployed. ISR enables pages to be statically generated at runtime by setting a `revalidate` property in `getStaticProps`, allowing you to specify the time interval after which a page is regenerated. This improves performance by serving cached pages and SEO by ensuring search engines always index the most up-to-date content without the need for rebuilding the entire site. ISR allows a balance between static generation and dynamic updates."
        },
        {
            "question": "What are the benefits of using TypeScript with Next.js, and how do you configure it?",
            "answer": "TypeScript with Next.js provides benefits such as static type checking, better development experience with autocompletion, and easier debugging. It helps catch errors at compile time, improving code quality and maintainability. To configure TypeScript in a Next.js project, simply install the necessary TypeScript dependencies (`typescript`, `@types/react`, `@types/node`), and Next.js will automatically detect and generate the `tsconfig.json` file. TypeScript can be used with both server-side and client-side code, offering type safety throughout the application."
        },
        {
            "question": "How does Next.js handle routing?",
            "answer": "Next.js uses a file-based routing system. The structure of the pages in the 'pages' directory automatically maps to corresponding routes in the app, simplifying routing without additional configuration."
        },
        {
            "question": "What is server-side rendering in Next.js, and how is it implemented in Next.js?",
            "answer": "SSR generates HTML on the server for each request, improving SEO and initial load times. In Next.js, SSR is implemented using the getServerSideProps function, which runs on the server for each request."
        },
        {
            "question": "How does Next.js handle CSS, and what are the different options for styling a Next.js application?",
            "answer": "Next.js supports several styling options: global CSS files, CSS modules, styled-components, and inline styles. Global CSS can be applied by importing `.css` files in `_app.js` or `pages/_document.js`. CSS modules allow scoping styles locally to components by using file names with the `.module.css` suffix. Styled-components is a CSS-in-JS library that allows you to write CSS directly within your JavaScript code, with automatic scoping. Additionally, Next.js supports the use of SASS/SCSS by installing the necessary packages. Inline styles are also an option, though they don’t support features like pseudo-classes and media queries."
        },
        {
            "question": "What is static site generation (SSG) in Next.js?",
            "answer": "Static Site Generation (SSG) in Next.js allows you to pre-render pages at build time. This means that the content is generated once during the build process and served as static HTML, improving performance and SEO."
        },
        {
            "question": "What is the difference between Link and regular HTML <a> tags in Next.js?",
            "answer": "The Link component enables client-side navigation with prefetching for faster page transitions, while <a> performs a full-page reload."
        },
        {
            "question": "How do you manage environment variables in Next.js, and what are the best practices?",
            "answer": "In Next.js, environment variables are managed through `.env` files, which can be specific to different environments (e.g., `.env.local`, `.env.production`). Variables defined in these files are accessible in the application via `process.env.<VARIABLE_NAME>`. For client-side access, variables must be prefixed with `NEXT_PUBLIC_`, making them publicly available in the frontend. Best practices include keeping sensitive data, like API keys, only on the server side and avoiding exposing them to the client. Also, ensure that environment variables are set up for each deployment environment (development, staging, production)."
        },
        {
            "question": "How can you prefetch data in Next.js?",
            "answer": "Data is prefetched automatically with the Link component. For manual prefetching, use router.prefetch()."
        },
        {
            "question": "How does Next.js handle automatic code splitting?",
            "answer": "Next.js automatically splits code by creating separate bundles for each page of the app. This allows only the necessary code to be loaded when a page is requested, improving load times and performance."
        },
        {
            "question": "What is the role of 'getStaticProps' in Next.js?",
            "answer": "'getStaticProps' is a Next.js function that allows you to fetch data at build time for static pages. It helps in pre-rendering pages with dynamic data, improving performance and SEO."
        },
        {
            "question": "What is the purpose of `getServerSideProps` in Next.js, and how does it differ from `getStaticProps`?",
            "answer": "`getServerSideProps` is used in Next.js to fetch data on the server for every request, meaning it runs on every page load. It is ideal for dynamic data that needs to be fetched on each request, such as user-specific information or frequently changing data. In contrast, `getStaticProps` runs at build time and generates static content, making it faster and more suitable for static content that doesn’t need to change frequently. `getServerSideProps` is used when you need real-time data, while `getStaticProps` is used when data is static or updated at build time."
        },
        {
            "question": "What is the role of `next/head` in Next.js, and how would you use it to manage SEO and metadata?",
            "answer": "`next/head` is a component in Next.js that allows you to manage the contents of the `<head>` tag of a page, such as setting the page title, meta tags, and other SEO-related elements. It is crucial for managing SEO and improving visibility in search engines. You can dynamically modify the head tag for each page using `<Head>` to define things like the title, description, and open graph meta tags. This ensures that search engines index relevant metadata for each page of your site, improving SEO and social media sharing."
        },
        {
            "question": "What is the difference between `next/image` and using a regular `<img>` tag in Next.js?",
            "answer": "`next/image` is a built-in Next.js component that provides automatic optimization for images, including lazy loading, responsive image sizes, and image format switching (like WebP) based on the user's device. This results in better performance by reducing page load time. The regular `<img>` tag does not provide these optimizations out of the box and requires manual configuration for responsive images, lazy loading, and format switching. `next/image` also provides better SEO performance by automatically serving images with optimized dimensions and improved accessibility."
        },
        {
            "question": "What is the purpose of `next/link` and how does it optimize routing in Next.js?",
            "answer": "`next/link` is a built-in Next.js component used for client-side navigation between pages within a Next.js application. It optimizes routing by preloading linked pages in the background when they are near the viewport, reducing page load time and improving user experience. Unlike the traditional `<a>` tag in HTML, `next/link` ensures that page transitions are handled using the client-side JavaScript, enabling faster navigation and avoiding full page reloads. Additionally, `next/link` provides support for dynamic routing, query parameters, and more advanced URL handling."
        },
        {
            "question": "Can I use custom Babel and Webpack configurations in Next.js?",
            "answer": "Yes, Next.js allows you to customize Babel and Webpack configurations. You can modify these configurations to suit your project's specific needs by editing the next.config.js file."
        },
        {
            "question": "What is the purpose of `getInitialProps` in Next.js, and how does it differ from `getServerSideProps`?",
            "answer": "`getInitialProps` is a Next.js data fetching method that was used in older versions of Next.js to fetch data on the server side before rendering a page. It runs on both the server and the client and can be used to fetch data before the page is initially rendered. However, `getServerSideProps` is preferred over `getInitialProps` in modern Next.js applications because it only runs on the server-side and does not execute client-side. `getServerSideProps` also supports better optimizations and is more suited for handling dynamic data in modern Next.js projects."
        },
        {
            "question": "How can you configure custom webpack in Next.js, and why would you need to do this?",
            "answer": "In Next.js, you can customize the Webpack configuration by modifying the `next.config.js` file. You can extend the default configuration by using the `webpack` field inside `next.config.js`, where you can add loaders, plugins, or other configuration settings. Custom webpack configuration may be needed for adding specific processing rules for assets, integrating third-party libraries that require custom bundling, or optimizing performance. However, it is important to note that Next.js comes with a set of sensible defaults, and customization should be done only when necessary to avoid conflicts."
        },
        {
            "question": "What is the difference between static generation and server-side rendering in Next.js?",
            "answer": "Static Generation pre-renders pages at build time, and the content is served as static HTML. Server-side rendering (SSR) generates the content on the server for each request, ensuring up-to-date data on every request."
        },
        {
            "question": "What are the differences between using a custom server and the default server in Next.js?",
            "answer": "A custom server provides fine-grained control over requests but requires more configuration and can complicate deployments. The default server is optimized for most use cases."
        },
        {
            "question": "Explain the use case of React Server Components (RSC) in Next.js.",
            "answer": "RSC allows rendering React components on the server, reducing client-side JavaScript and improving performance for complex UI."
        },
        {
            "question": "How does Next.js handle static assets, and what are the best practices for serving images, fonts, and other media?",
            "answer": "Next.js handles static assets by serving them from the `public` directory, where any file placed inside this folder is served directly at the root of the website (e.g., `/images/logo.png`). For images, Next.js provides the `next/image` component, which automatically optimizes images by serving them in modern formats, resizing, and lazy loading them for improved performance. For fonts and other static media, it is recommended to use the `next/font` module for font optimization and to keep the media files in the `public` directory or import them using Webpack for bundling and optimization."
        },
        {
            "question": "What are Edge Functions, and how are they used in Next.js?",
            "answer": "Edge Functions run at the CDN edge, enabling low-latency responses for tasks like A/B testing or geolocation-based content."
        },
        {
            "question": "Describe how you would implement authentication in a Next.js application.",
            "answer": "Use API routes for authentication logic, secure cookies or JWT for session management, and middleware for route protection."
        },
        {
            "question": "How can you implement authorization in a Next.js application?",
            "answer": "Authorization in Next.js can be implemented by first managing authentication (e.g., using JWT tokens, OAuth, or third-party services like Auth0) to verify the user's identity. Once authenticated, you can store user data (e.g., in cookies or JWT tokens) and manage user sessions using server-side methods like `getServerSideProps` to verify access to certain pages or API routes. On the client side, you can use React context or state management to track the user's authorization status. For page-level authorization, you can protect specific pages or routes by redirecting unauthorized users to a login page. For example, in `getServerSideProps`, you can check the user's session or token and return a `redirect` object if the user is not authorized."
        },
        {
            "question": "Explain the concept of API routes in Next.js and how they differ from traditional backend APIs.",
            "answer": "API routes in Next.js allow you to build server-side logic directly within the Next.js application without the need for an external backend. Each file in the `pages/api` directory automatically becomes an endpoint, and the exported function handles the HTTP request and response. This differs from traditional backend APIs, where you typically need a separate server (like Express.js or NestJS) to manage API routes. Next.js API routes are fully integrated with the application and provide a simple, serverless way to handle API requests within the same framework."
        },
        {
            "question": "What is the concept of 'middleware' in Next.js and how can it be used?",
            "answer": "Middleware in Next.js refers to code that runs before a request is completed, allowing you to add custom logic before the page is rendered. It allows for functionality like authentication checks, redirects, logging, and more. Middleware in Next.js can be defined in a special `_middleware.js` file at any directory level (e.g., in `pages/api` for API routes or in the `pages` directory). Middleware runs before the page is loaded or API routes are called, providing a powerful tool for handling things like authentication and authorization without needing to modify each page or route."
        },
        {
            "question": "What is the purpose of `next/export` in Next.js, and when would you use it?",
            "answer": "`next/export` is a feature in Next.js that allows you to export your Next.js app as a fully static website. This can be useful when you want to deploy your app to a static hosting service like GitHub Pages, Netlify, or Vercel in a non-dynamic way. When you run `next export`, Next.js generates a static version of your app with HTML files for every route, ensuring that the entire app can be served as a static site. You would use `next/export` if you have an app that doesn't need server-side rendering or API routes and can be pre-rendered completely at build time."
        },
        {
            "question": "What is the purpose of `next/dynamic` in Next.js, and how does it help with performance optimization?",
            "answer": "`next/dynamic` is a Next.js feature that allows you to dynamically import components, enabling lazy loading. By dynamically importing components, you reduce the initial JavaScript bundle size, improving the performance and load time of your app. This is particularly useful for components that are not immediately necessary, such as modals, charts, or large UI components that can be loaded only when required. It also supports server-side rendering (SSR) and the ability to use `loading` components while the dynamically imported component is being fetched."
        },
        {
            "question": "How does Next.js handle fallback pages for dynamic routes?",
            "answer": "Fallback pages display a loading state until the dynamic content is fetched. It’s controlled using the fallback property in getStaticPaths."
        },
        {
            "question": "How would you optimize a Next.js application with a large number of dynamic pages?",
            "answer": "Use ISR to regenerate pages as needed, define efficient paths in getStaticPaths, and cache API responses."
        },
        {
            "question": "What steps would you take to migrate a React app to Next.js?",
            "answer": "Replace the routing system with file-based routing, implement SSR/SSG where needed, and configure API routes for backend logic."
        },
        {
            "question": "How would you handle error pages in Next.js (e.g., 404 or 500 errors)?",
            "answer": "Customize error pages by creating 404.js and 500.js in the pages directory. Use ErrorBoundary components for handling runtime errors."
        },
        {
            "question": "How do you implement a multi-language (i18n) application in Next.js?",
            "answer": "Use the built-in internationalization (i18n) feature in next.config.js or libraries like next-i18next for language detection, translation files, and routing."
        },
        {
            "question": "What are the security considerations when deploying a Next.js application, and how can you mitigate potential risks?",
            "answer": "When deploying a Next.js application, it's important to consider security risks such as cross-site scripting (XSS), cross-site request forgery (CSRF), and server-side vulnerabilities. To mitigate these risks, you should sanitize and validate user inputs, ensure that sensitive information like API keys is stored in environment variables, and never expose them to the client. Use secure HTTP headers such as `Content-Security-Policy`, `Strict-Transport-Security`, and `X-Frame-Options` to prevent XSS and clickjacking attacks. Additionally, consider using HTTPS for all communications and implement proper authentication and authorization mechanisms for protected routes. Regularly update dependencies and monitor for vulnerabilities using tools like Snyk or Dependabot."
        },
        {
            "question": "How do you handle large-scale applications with Next.js, especially when dealing with multiple teams and micro-frontends?",
            "answer": "Handling large-scale applications with Next.js can be done effectively by using a modular approach, splitting the app into smaller, manageable pieces (micro-frontends). Each micro-frontend can be developed and deployed independently by different teams, improving scalability and reducing the complexity of the overall system. In Next.js, you can leverage features like dynamic imports, API routes, and incremental static regeneration (ISR) to keep parts of the application independent and performant. Additionally, managing the application with a monorepo using tools like Nx or Lerna can simplify dependency management and improve collaboration between multiple teams working on the same codebase."
        }
    ],
    "reactjs": [
        {
            "question": "What is React.js?",
            "answer": "React.js is an open-source JavaScript library used for building user interfaces, primarily for single-page applications. It allows developers to create reusable UI components and manage the view layer efficiently."
        },
        {
            "question": "What are the major features of React?",
            "answer": "The major features of React are: Uses JSX syntax, a syntax extension of JS that allows developers to write HTML in their JS code. It uses Virtual DOM instead of Real DOM considering that Real DOM manipulations are expensive. Supports server-side rendering which is useful for Search Engine Optimizations(SEO). Follows Unidirectional or one-way data flow or data binding. Uses reusable/composable UI components to develop the view."
        },
        {
            "question": "What are React components?",
            "answer": "React components are independent, reusable pieces of UI that represent parts of a user interface. They can be defined as functions (functional components) or classes (class components) and can manage their own state."
        },
        {
            "question": "What is JSX in React?",
            "answer": "JSX stands for JavaScript XML. It is a syntax extension for JavaScript that allows you to write HTML-like code inside JavaScript. JSX makes it easier to describe the UI and integrates seamlessly with React components."
        },
        {
            "question": "What is React Fiber?",
            "answer": "Fiber is the new reconciliation engine or reimplementation of core algorithm in React v16. The goal of React Fiber is to increase its suitability for areas like animation, layout, gestures, ability to pause, abort, or reuse work and assign priority to different types of updates; and new concurrency primitives."
        },
        {
            "question": "What is the main goal of React Fiber?",
            "answer": "The goal of React Fiber is to increase its suitability for areas like animation, layout, and gestures. Its headline feature is incremental rendering: the ability to split rendering work into chunks and spread it out over multiple frames."
        },
        {
            "question": "What is the difference between Element and Component?",
            "answer": "An Element is a plain object describing what you want to appear on the screen in terms of the DOM nodes or other components. Elements can contain other Elements in their props. Creating a React element is cheap. Once an element is created, it cannot be mutated."
        },
        {
            "question": "What is the Virtual DOM in React?",
            "answer": "The Virtual DOM is a lightweight JavaScript representation of the real DOM. React uses it to efficiently update and render components by comparing the Virtual DOM with the real DOM and applying changes only to the necessary elements."
        },
        {
            "question": "What is ReactDOM in React?",
            "answer": "ReactDOM is a package that provides DOM-specific methods to interact with the DOM. It includes methods like `ReactDOM.render()`, which is used to render React components to the DOM, and `ReactDOM.hydrate()`, which is used for server-side rendering (SSR). ReactDOM acts as a bridge between React's virtual DOM and the browser's actual DOM."
        },
        {
            "question": "What is ReactDOMServer?",
            "answer": "The ReactDOMServer object enables you to render components to static markup, which is typically used in server-side rendering (SSR) on a Node server. It is useful for generating HTML strings that can be sent to the client for faster initial loading and SEO optimization. ReactDOMServer provides two primary methods: 1) renderToString(): Renders a React element to its initial HTML as a string. 2) renderToStaticMarkup(): Similar to renderToString() but does not include additional React-specific attributes, making it suitable for static sites."
        },
        {
            "question": "What are props in React?",
            "answer": "Props (short for properties) are read-only inputs passed from a parent component to a child component. They are used to pass data and configuration to child components and cannot be modified within the child component."
        },
        {
            "question": "What is state in React?",
            "answer": "State is an object in React components that holds dynamic data that can change over time. Unlike props, the state is mutable and is managed within the component. Changes to state trigger re-rendering of the component."
        },
        {
            "question": "What is the difference between state and props in React?",
            "answer": "In React, **props** (short for properties) are used to pass data from a parent component to a child component. Props are immutable and cannot be changed by the child component. **State**, on the other hand, is a local data store that can be modified by the component that owns it. State is used to manage dynamic data within a component, and when state changes, the component re-renders."
        },
        {
            "question": "What is the difference between functional and class components in React?",
            "answer": "Functional components are simpler and do not have their own state or lifecycle methods (prior to React Hooks). Class components can manage state and have access to lifecycle methods. With Hooks, functional components can now use state and lifecycle-like features."
        },
        {
            "question": "What are the different types of errors in React?",
            "answer": "React errors can generally be categorized into three types: \n1. **JavaScript Errors**: These are errors that occur during the execution of JavaScript code, such as accessing an undefined variable or function. \n2. **React Errors**: These are errors specific to React, like invalid props or wrong usage of React APIs. \n3. **Rendering Errors**: These occur when React fails to render components properly, often caused by incorrect JSX syntax, invalid return values, or errors in lifecycle methods."
        },
        {
            "question": "What are React Hooks?",
            "answer": "React Hooks are functions that allow functional components to use state and other React features, like lifecycle methods. Common hooks include 'useState', 'useEffect', and 'useContext'."
        },
        {
            "question": "What is the purpose of the 'useState' hook?",
            "answer": "The 'useState' hook is used to add state to functional components. It returns a state variable and a function to update that state. Example: '[count, setCount] = useState(0)'."
        },
        {
            "question": "What is the 'useEffect' hook used for?",
            "answer": "The 'useEffect' hook is used to handle side effects in functional components, such as fetching data, subscribing to events, or manually changing the DOM. It can also clean up resources using the cleanup function."
        },
        {
            "question": "What is the difference between `componentDidMount` and `useEffect`?",
            "answer": "`componentDidMount` is a lifecycle method in class components that runs once when the component is first mounted. In contrast, `useEffect` is used in functional components to perform side effects, and it can run after every render or only once, depending on the dependency array provided. While `componentDidMount` runs once, `useEffect` can be configured for a more flexible behavior."
        },
        {
            "question": "What is the difference between controlled and uncontrolled components in React?",
            "answer": "Controlled components have their state managed by React through props, whereas uncontrolled components rely on the DOM to manage their state and use refs to access their values."
        },
        {
            "question": "What is the context API in React?",
            "answer": "The Context API is a feature in React that allows you to share data (like themes, user authentication) across components without passing props manually at every level. It provides a way to create global variables accessible throughout the component tree."
        },
        {
            "question": "What are higher-order components (HOCs) in React?",
            "answer": "HOCs are functions that take a component as input and return a new component with enhanced functionality. They are used for code reuse, state abstraction, and manipulating props."
        },
        {
            "question": "What is React Router?",
            "answer": "React Router is a library used for routing in React applications. It enables navigation between different views or components without reloading the page. It provides components like '<BrowserRouter>', '<Route>', and '<Link>'."
        },
        {
            "question": "How React Router is different from history library?",
            "answer": "React Router is a wrapper around the history library which handles interaction with the browser's window.history with its browser and hash histories. It also provides memory history which is useful for environments that don't have global history, such as mobile app development (React Native) and unit testing with Node."
        },
        {
            "question": "What are the <Router> components of React Router v4?",
            "answer": "In React Router v4, the primary Router components include: <BrowserRouter>, <HashRouter>, <MemoryRouter>, <Route>, <Link>, and <Redirect>. The <BrowserRouter> is the most commonly used and provides a clean URL path, while the <HashRouter> uses URL hashes to manage routing. <MemoryRouter> is used for in-memory routing, typically in non-browser environments like tests. <Route> is used to define the route paths, and <Link> is used to navigate between routes. <Redirect> is used to navigate programmatically or redirect users based on certain conditions."
        },
        {
            "question": "Why you get 'Router may have only one child element' warning?",
            "answer": "You have to wrap your Route's in a <Switch> block because <Switch> is unique in that it renders a route exclusively."
        },
        {
            "question": "What is React Intl?",
            "answer": "React Intl is a library used for internationalization (i18n) in React applications. It provides components and APIs to help with formatting numbers, dates, times, and messages in different languages and locales. React Intl uses the built-in JavaScript Internationalization API to handle the complexities of language and locale-specific formatting. It helps developers to create multilingual applications by enabling dynamic rendering of content based on the user's locale or language preferences.\n\nKey features include:\n\n1) Formatted messages: Enables translation of text in the app.\n2) Date/Time/Number formatting: Allows locale-sensitive formatting of dates, times, and numbers.\n3) Pluralization and gender support: Handles language-specific pluralization and gender-based translations.\n4) Locale management: Helps manage different locales and switch between them dynamically.\n\nReact Intl is commonly used in React applications to make them accessible to a global audience by supporting multiple languages and regional settings."
        },
        {
            "question": "What are the main features of React Intl?",
            "answer": "Below are the main features of React Intl:\n\n1) **Display numbers with separators**: Automatically formats numbers with appropriate separators based on locale.\n2) **Display dates and times correctly**: Formats dates and times according to the locale, ensuring correct display of months, days, and time zones.\n3) **Display dates relative to 'now'**: Formats dates relative to the current time (e.g., '5 minutes ago').\n4) **Pluralize labels in strings**: Handles pluralization rules for different languages, displaying singular or plural forms appropriately.\n5) **Support for 150+ languages**: Offers built-in support for over 150 languages and regions.\n6) **Runs in the browser and Node**: Can be used both in client-side (browser) and server-side (Node.js) applications.\n7) **Built on standards**: Based on the JavaScript Internationalization API (Intl), ensuring compatibility with the standard i18n practices."
        },
        {
            "question": "What is Shallow Renderer in React testing?",
            "answer": "Shallow rendering is useful for writing unit test cases in React. It lets you render a component one level deep and assert facts about what its render method returns, without worrying about the behavior of child components, which are not instantiated or rendered."
        },
        {
            "question": "What is the purpose of ReactTestUtils package?",
            "answer": "ReactTestUtils are provided in the with-addons package and allow you to perform actions against a simulated DOM for the purpose of unit testing."
        },
        {
            "question": "What are the advantages of Jest over Jasmine?",
            "answer": "There are several advantages of Jest compared to Jasmine:\n\n1) **Automatically finds tests to execute**: Jest automatically detects and runs tests in your source code without needing manual setup.\n2) **Automatically mocks dependencies**: Jest comes with built-in mocking capabilities, making it easier to mock dependencies when running tests.\n3) **Allows testing asynchronous code synchronously**: Jest has built-in support for testing asynchronous code and allows it to be written and tested synchronously.\n4) **Runs tests with a fake DOM (via jsdom)**: Jest uses jsdom, providing a simulated DOM environment that allows tests to run without a real browser.\n5) **Runs tests in parallel processes**: Jest runs tests in parallel processes, which leads to faster test execution and better performance compared to Jasmine."
        },
        {
            "question": "What is TestRenderer package in React?",
            "answer": "This package provides a renderer that can be used to render components to pure JavaScript objects, without depending on the DOM or a native mobile environment. This package makes it easy to grab a snapshot of the platform view hierarchy (similar to a DOM tree) rendered by a ReactDOM or React Native without using a browser or jsdom."
        },
        {
            "question": "What is the purpose of `React.Fragment`?",
            "answer": "React.Fragment is a wrapper component that allows you to group multiple child elements without adding extra nodes to the DOM. It is commonly used when a component needs to return multiple elements but without introducing additional HTML elements like a `<div>`. This helps keep the DOM structure clean and avoids unnecessary nesting."
        },
        {
            "question": "What is the difference between 'React.Fragment' and a div container?",
            "answer": "'React.Fragment' is a wrapper used to group multiple child elements without adding an extra DOM node, unlike a div container which creates an additional element in the DOM."
        },
        {
            "question": "What is the purpose of keys in React lists?",
            "answer": "Keys are unique identifiers used in React lists to track items efficiently. They help React identify which elements have changed, been added, or removed, improving rendering performance."
        },
        {
            "question": "What is the difference between 'useMemo' and 'useCallback'?",
            "answer": "'useMemo' is used to memoize the result of a computation, while 'useCallback' is used to memoize a callback function to avoid unnecessary re-creations during re-renders."
        },
        {
            "question": "Explain the use of the useState hook in React.",
            "answer": "The `useState` hook in React is used to add state to functional components. It allows you to declare a state variable and a function to update its value. The `useState` hook accepts the initial state value as an argument and returns an array containing the current state and the updater function. Whenever the state changes, React re-renders the component with the updated state. Example: `const [count, setCount] = useState(0);`"
        },
        {
            "question": "What are Portals in React?",
            "answer": "Portals provide a way to render children into a different part of the DOM tree outside of their parent component. They are useful for rendering modals, tooltips, or dropdowns, where the component needs to appear outside the normal DOM hierarchy of its parent component. Portals are created using `ReactDOM.createPortal()`."
        },
        {
            "question": "What is React's default behavior for event handling?",
            "answer": "In React, event handling follows a synthetic event system, which normalizes events across different browsers. React automatically manages event binding, meaning you don't need to manually bind event handlers to `this` as in traditional JavaScript. React events are passed as the first argument to the event handler, and you can prevent default behavior or stop propagation using methods like `event.preventDefault()` and `event.stopPropagation()`."
        },
        {
            "question": "What is the difference between `props.children` and `this.props.children`?",
            "answer": "`props.children` refers to the special `children` prop that is passed to a component and contains any child elements nested inside the component when used in JSX. In functional components, you access it directly as `props.children`, whereas in class components, you access it through `this.props.children` since `props` is part of the class instance."
        },
        {
            "question": "What are React Suspense and React.lazy?",
            "answer": "React **Suspense** is a feature that allows you to handle the loading state of components that are being dynamically imported, typically through **React.lazy**. **React.lazy** enables code-splitting by allowing you to load components only when they are needed, rather than all at once. Suspense provides a way to show a loading state (like a spinner) while the component is being loaded, and once it's ready, it will render the component."
        },
        {
            "question": "What is formik?",
            "answer": "Formik is a small react form library that helps you with the three major problems: Getting values in and out of form state. Validation and error messages. Handling form submission"
        },
        {
            "question": "What is code-splitting?",
            "answer": "Code-Splitting is a feature supported by bundlers like Webpack and Browserify which can create multiple bundles that can be dynamically loaded at runtime. The react project supports code splitting via dynamic import() feature."
        },
        {
            "question": "What is the useEffect hook, and why is it used?",
            "answer": "The `useEffect` hook is used for handling side effects in functional components, such as fetching data, subscribing to events, or manually interacting with the DOM. It runs after the component renders and can be configured to run only once, on every render, or when certain dependencies change. It replaces lifecycle methods like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` in class components. Example: `useEffect(() => { fetchData(); }, [dependencies]);`"
        },
        {
            "question": "Explain the useContext hook.",
            "answer": "The `useContext` hook is used to access the value of a context in a functional component. It allows components to consume data from a context without needing to explicitly pass props down through multiple levels of the component tree. `useContext` takes the context object (created by `React.createContext()`) as an argument and returns the current context value. Example: `const theme = useContext(ThemeContext);`"
        },
        {
            "question": "What is the purpose of `useReducer` hook?",
            "answer": "`useReducer` is a React hook used for managing more complex state logic in functional components, especially when state depends on previous values or involves multiple sub-values. It is similar to `useState` but provides a more structured way of updating state using a reducer function, commonly used for complex state transitions or when managing state in forms or large applications."
        },
        {
            "question": "How does React handle forms?",
            "answer": "React handles forms by either using **controlled components** (where form inputs are controlled by React state) or **uncontrolled components** (where the DOM manages form inputs and React accesses them via refs). Controlled components are more common and allow React to manage the input data, update state on change, and validate the form before submission."
        },
        {
            "question": "What is the purpose of `useRef` in React?",
            "answer": "`useRef` is a hook that allows you to persist values across renders without causing re-renders. It can be used to reference DOM elements or to store mutable values that do not need to trigger a re-render when updated. It's commonly used to manage focus, measure element sizes, or hold references to child components."
        },
        {
            "question": "What is server-side rendering (SSR) in React?",
            "answer": "SSR is a technique where React components are rendered on the server and sent to the browser as fully-rendered HTML. It improves performance and SEO. Frameworks like Next.js facilitate SSR in React applications."
        },
        {
            "question": "What is client-side rendering (CSR) in React?",
            "answer": "Client-side rendering (CSR) is the process where the browser loads a minimal HTML page with React, and then React takes over to render the entire page in the client’s browser. CSR often provides a faster, more interactive experience after the initial page load, but can lead to slower initial loading times compared to server-side rendering."
        },
        {
            "question": "What is the difference between 'forEach' and 'map' in React?",
            "answer": "'forEach' iterates over an array and executes a callback function for each element but does not return anything. 'map' also iterates over an array but returns a new array with the results of the callback function."
        },
        {
            "question": "What is React's `strict mode`?",
            "answer": "React's `strict mode` is a development mode feature that helps developers identify potential problems in an application. It intentionally runs additional checks and warnings to help highlight unsafe lifecycle methods, legacy API usage, or side effects that may not be ideal. Strict mode does not affect the production build, only the development experience."
        },
        {
            "question": "How to enable production mode in React?",
            "answer": "You should use Webpack's DefinePlugin method to set NODE_ENV to production, by which it strip out things like propType validation and extra warnings. Apart from this, if you minify the code, for example, Uglify's dead-code elimination to strip out development only code and comments, it will drastically reduce the size of your bundle."
        },
        {
            "question": "What is a switching component?",
            "answer": "A switching component is a component that renders one of many components. We need to use object to map prop values to components."
        },
        {
            "question": "What are React Mixins?",
            "answer": "Mixins are a way to totally separate components to have a common functionality. Mixins should not be used and can be replaced with higher-order components or decorators."
        },
        {
            "question": "What are the Pointer Events supported in React?",
            "answer": "Pointer Events in React are a set of event handlers that allow handling interactions from pointing devices such as a mouse, pen, or touch. These events are supported in React for better cross-device compatibility. The supported Pointer Events include: \n\n1) onPointerDown: Triggered when a pointing device button is pressed.\n2) onPointerMove: Triggered when a pointing device is moved.\n3) onPointerUp: Triggered when a pointing device button is released.\n4) onPointerCancel: Triggered when the pointer event is canceled.\n5) onPointerEnter: Triggered when a pointing device enters the boundary of an element.\n6) onPointerLeave: Triggered when a pointing device leaves the boundary of an element.\n7) onPointerOver: Triggered when a pointing device is over an element.\n8) onPointerOut: Triggered when a pointing device is moved out of an element.\n9) onGotPointerCapture: Triggered when an element gains pointer capture.\n10) onLostPointerCapture: Triggered when an element loses pointer capture.\n\nThese events offer precise control over user interactions across different input types."
        },
        {
            "question": "What is the proper placement for error boundaries?",
            "answer": "The granularity of error boundaries usage is up to the developer based on project needs. You can follow either of these approaches: You can wrap top-level route components to display a generic error message for the entire application. You can also wrap individual components in an error boundary to protect them from crashing the rest of the application."
        },
        {
            "question": "What is the benefit of component stack trace from error boundary?",
            "answer": "Apart from error messages and JavaScript stack, React 16 will display the component stack trace with file names and line numbers using the error boundary concept. This makes it easier to debug and pinpoint the location of errors in the component hierarchy."
        },
        {
            "question": "Is it possible to use async/await in plain React?",
            "answer": "If you want to use async/await in React, you will need Babel and transform-async-to-generator plugin. React Native ships with Babel and a set of transforms."
        },
        {
            "question": "Do Hooks replace render props and higher order components?",
            "answer": "Both render props and higher-order components render only a single child but in most of the cases Hooks are a simpler way to serve this by reducing nesting in your tree."
        },
        {
            "question": "How to pass data from Parent to Child component and vice-versa?",
            "answer": "To pass data from a Parent to a Child component, use props. The parent passes data as attributes to the child component, which can be accessed in the child using 'props'. Example: '<ChildComponent data={value} />'. To pass data from a Child to a Parent component, use a callback function. The parent passes a function as a prop to the child. The child calls this function, often passing data as an argument. Example: 'props.onDataChange(data)'."
        },
        {
            "question": "What are synthetic events in React?",
            "answer": "Synthetic events in React are a cross-browser wrapper around the browser's native events. React implements its own event system that normalizes the events so that they behave consistently across different browsers. Synthetic events provide a consistent interface for events like `onClick`, `onChange`, etc., and also include additional features like event pooling, which helps in optimizing memory usage."
        },
        {
            "question": "Why we need to be careful when spreading props on DOM elements?",
            "answer": "When we spread props we run into the risk of adding unknown HTML attributes, which is a bad practice. Instead we can use prop destructuring with ...rest operator, so it will add only required props."
        },
        {
            "question": "What are stateless components?",
            "answer": "Stateless components, also known as functional components, are components in React that do not manage or hold their own state. They are simply functions that accept props as an argument and return React elements. Since they don't have lifecycle methods or internal state, they are simpler and often more efficient than stateful components."
        },
        {
            "question": "What are stateful components?",
            "answer": "Stateful components are React components that manage and maintain their own internal state. They can use lifecycle methods to respond to changes in state or props. Typically, stateful components are class components or functional components with hooks like useState or useReducer to handle dynamic data and interactivity."
        },
        {
            "question": "What is the difference between a stateless component and a stateful component?",
            "answer": "A **stateless component** is a component that does not manage or hold any local state. It only receives props from its parent component and renders UI based on those props. A **stateful component**, on the other hand, manages its own state and can modify it over time using state-changing methods like `setState` (in class components) or `useState` (in functional components). Stateful components are more interactive because they can update themselves in response to user actions or other events."
        },
        {
            "question": "Describe the lifecycle methods in a React class component.",
            "answer": "Lifecycle methods in a React class component allow you to hook into specific moments in a component's lifecycle: mounting, updating, and unmounting. \n1. **Mounting**: When a component is created and inserted into the DOM, the methods are: \n   - `constructor()`: Initializes state and binds methods.\n   - `static getDerivedStateFromProps()`: Updates state based on props (rarely used).\n   - `render()`: Returns the JSX to render the component.\n   - `componentDidMount()`: Executes after the component is mounted, ideal for side effects like API calls.\n2. **Updating**: Called when props or state changes. Methods include:\n   - `static getDerivedStateFromProps()`: Updates state based on new props.\n   - `shouldComponentUpdate()`: Determines if the component should re-render.\n   - `render()`: Re-renders the component.\n   - `componentDidUpdate()`: Executes after re-rendering, used for side effects like updating DOM or fetching data.\n3. **Unmounting**: Called when the component is removed from the DOM. Method:\n   - `componentWillUnmount()`: Used for cleanup, such as clearing timers or unsubscribing from events."
        },
        {
            "question": "What is the significance of the `dangerouslySetInnerHTML` attribute in React?",
            "answer": "`dangerouslySetInnerHTML` is a React attribute that allows you to directly inject HTML content into a component. It is considered 'dangerous' because it bypasses React’s built-in DOM sanitation and can expose the application to XSS (Cross-Site Scripting) attacks if the content is not properly sanitized. It should be used cautiously and only with trusted content."
        },
        {
            "question": "What is `shouldComponentUpdate` and when should you use it?",
            "answer": "`shouldComponentUpdate` is a lifecycle method in class components that allows you to control whether a component should re-render when it receives new props or state. By default, React re-renders components on every state or props change. However, `shouldComponentUpdate` can be used to optimize performance by preventing unnecessary re-renders. It is commonly used in components with complex UIs where re-renders can be costly."
        },
        {
            "question": "How can we achieve lifecycle methods in a functional component?",
            "answer": "In functional components, lifecycle methods are achieved using React Hooks, especially 'useEffect'. The 'useEffect' hook can handle mounting, updating, and unmounting phases of a component's lifecycle. \n1. **Mounting**: Use 'useEffect' without a dependency array to execute code once when the component is first rendered. \n2. **Updating**: Use 'useEffect' with a dependency array to execute code whenever the specified dependencies change. \n3. **Unmounting**: Use the cleanup function returned by 'useEffect' to execute code when the component is removed from the DOM. This handles tasks like clearing timers or unsubscribing from events."
        },
        {
            "question": "What are error boundaries in React?",
            "answer": "Error boundaries in React are special components that catch JavaScript errors anywhere in their child component tree and log those errors. They also allow you to display a fallback UI when an error occurs, preventing the entire application from crashing. Error boundaries are typically used to handle errors in production environments and provide users with a smooth experience even when things go wrong."
        },
        {
            "question": "What are PropTypes in React?",
            "answer": "PropTypes is a built-in type-checking feature in React that helps developers enforce the types of props passed to components. PropTypes allows you to specify the expected type, shape, and requirements for props (such as whether a prop is required, or what type it should be). It helps catch bugs early by warning developers when a prop does not match the expected type."
        },
        {
            "question": "What are Pure Components?",
            "answer": "Pure Components in React are components that only re-render when their props or state change. They implement a shallow comparison of props and state in their `shouldComponentUpdate` method, which allows React to optimize performance by preventing unnecessary re-renders. In class components, `React.PureComponent` is used to create a pure component, while in functional components, pure behavior can be achieved by using `React.memo`. A Pure Component is ideal for static or immutable data."
        },
        {
            "question": "What is `React.memo` in React?",
            "answer": "`React.memo` is a higher-order component that allows functional components to skip re-rendering when the props have not changed. It’s used to optimize performance in functional components by preventing unnecessary re-renders. React.memo performs a shallow comparison of props by default, but you can pass a custom comparison function to optimize it further."
        },
        {
            "question": "What is the significance of React's reconciliation algorithm?",
            "answer": "React's reconciliation algorithm is responsible for efficiently updating the DOM when changes occur in the component's state or props. When a component re-renders, React compares the new Virtual DOM with the previous one, identifying the differences. It then calculates the minimum number of changes needed and applies them to the actual DOM, improving performance and minimizing unnecessary re-renders."
        },
        {
            "question": "How do you manage state across components in React?",
            "answer": "State management across components in React can be achieved by: \n1. **Lifting State Up**: Moving state to a common ancestor and passing it down as props. \n2. **React Context API**: Using context to share state globally without passing props manually. \n3. **State Management Libraries**: Using external libraries like Redux, MobX, or Recoil for more complex state management scenarios."
        },
        {
            "question": "What are the advantages of React?",
            "answer": "Some of the key advantages of React are: \n1. **Declarative UI**: React allows developers to describe how the UI should look based on the state, making it easier to understand and maintain. \n2. **Component-Based Architecture**: React's modular, reusable components promote better organization and reusability of code. \n3. **Virtual DOM**: React's Virtual DOM ensures faster UI updates by reducing direct manipulations of the actual DOM. \n4. **Unidirectional Data Flow**: React's one-way data binding ensures better control over data flow and simplifies debugging. \n5. **Large Ecosystem**: React has a vast ecosystem with tools, libraries, and community support for building scalable applications."
        },
        {
            "question": "What are the different ways to pass data from child component to parent component in React?",
            "answer": "There are several ways to pass data from a child component to a parent component in React:\n\n1. **Callback Functions**: The parent passes a callback function to the child as a prop. The child then calls this function with data as an argument, allowing the parent to access the data.\n2. **Refs**: A parent component can use `useRef` or `createRef` to pass a reference to the child component. The child can then modify the ref and the parent can access it.\n3. **Context API**: The Context API can be used for sharing state between parent and child components without having to pass props manually through intermediate components.\n\nThe most common and straightforward way is using **callback functions**, where the parent controls the flow of data."
        },
        {
            "question": "What is Lazy loading in React?",
            "answer": "Lazy loading in React is a technique that allows you to load components or modules only when they are required, instead of loading them at the start. It helps improve performance by reducing the initial loading time of an application. React provides `React.lazy()` for dynamic imports, combined with the `Suspense` component to handle loading states while the component is being loaded. This is useful for large applications where only certain parts of the UI need to be loaded at a time."
        },
        {
            "question": "What are Refs in React?",
            "answer": "Refs (short for references) in React are used to directly access a DOM element or a class instance in a component. React provides the `useRef` hook (for functional components) and `createRef` (for class components) to create references. Refs can be used for tasks like focusing input elements, measuring the size of a DOM node, or triggering imperative animations. They do not trigger re-renders, making them useful for non-visual updates."
        },
        {
            "question": "What is meant by forward ref in React?",
            "answer": "In React, `forwardRef` is a higher-order component that allows a component to forward its ref to a child component. This is useful when you want to pass a ref from a parent to a child component, especially when the child component is a function component. Normally, function components do not accept `ref` props, but `forwardRef` allows you to wrap the component and forward the ref to a DOM element or another component."
        },
        {
            "question": "What are the differences between `package.json` and `package-lock.json`?",
            "answer": "`package.json` and `package-lock.json` are both important files in a Node.js project, but they serve different purposes:\n\n1. **package.json**: This file defines the dependencies, scripts, and metadata of a project. It lists the project’s required dependencies (with version ranges), devDependencies, and scripts for running build processes, testing, and more. It is meant to be manually edited and shared among collaborators.\n2. **package-lock.json**: This file is automatically generated when `npm install` is run. It locks the exact versions of dependencies that were installed, ensuring that all developers and environments use the same versions of the dependencies. It ensures deterministic builds by specifying the precise dependency tree, including sub-dependencies.\n\nIn summary, `package.json` specifies the project’s dependencies, while `package-lock.json` locks down the exact versions to ensure consistency across installations."
        },
        {
            "question": "Can I use keys for non-list items?",
            "answer": "No, React requires `keys` to be used only in lists (arrays of elements) where items can change order or be added/removed. Keys help React identify which items have changed, been added, or removed, optimizing the rendering process. While it is technically possible to use keys for non-list items (like individual components), it's unnecessary and doesn't provide any performance benefits, as React's reconciliation algorithm only uses keys to track list items for optimal updates."
        },
        {
            "question": "What will happen by defining nested function components?",
            "answer": "Defining nested function components in React is perfectly valid and often used for organizing and structuring code. A nested function component is simply a function component that is defined inside another component. When you define nested components, the parent component can render the nested child component, passing props if needed.\n\nThe behavior will be the same as when defining separate components: React will render the child component and manage its lifecycle as usual. However, there are some considerations:\n\n1. **Performance**: Each time the parent component re-renders, the nested child components will also be redefined and potentially cause unnecessary re-renders if they aren't memoized properly.\n2. **Code readability**: While nesting can improve the structure of your code, excessive nesting may affect readability and make it harder to maintain.\n\nIn general, nested function components are commonly used for modularizing UI elements and improving code maintainability, but you should ensure proper optimization (e.g., using `React.memo`) to avoid unnecessary renders."
        },
        {
            "question": "How to send data from a child component to a parent using useRef?",
            "answer": "In React, `useRef` can be used to create a reference to a DOM element or a function within a child component, which can then be accessed by the parent component. To send data from a child to a parent using `useRef`, the parent can pass a `ref` to the child component, and the child can modify or set values directly on the `ref` object. Here's how it works:\n\n1. The parent defines a `useRef` in its state.\n2. The parent passes this `ref` as a prop to the child component.\n3. In the child, you can assign data or functions to the `ref` to make them accessible to the parent.\n\nThis is particularly useful when you want to expose methods or data from the child to the parent without directly passing the data via props."
        },
        {
            "question": "How do you use immer library for state updates?",
            "answer": "The `immer` library simplifies working with immutable state updates in JavaScript. It allows you to write code that 'mutates' state directly while actually producing a new state object under the hood. To use `immer`, you simply pass your current state to the `produce` function provided by the library.\n\nExample usage:\n1. Import `produce` from `immer`.\n2. Pass the current state and a function that modifies the state to `produce`.\n3. `immer` ensures that the state is updated immutably, returning a new state object.\n\nThis is especially useful for working with nested data structures, as `immer` allows you to avoid manually copying and spreading each level of the object."
        },
        {
            "question": "How do you update objects inside state?",
            "answer": "To update objects inside state in React, you should avoid directly mutating the state object. Instead, you can use methods like the **spread operator** (`...`) to create a new object with the updated values.\n\nExample:\n\n1. Access the state using the `useState` hook.\n2. Use the spread operator to copy the existing state into a new object.\n3. Update the specific property of the object in the new object.\n4. Set the new object as the updated state using the state setter function.\n\nExample code:\n\n```javascript\nconst [state, setState] = useState({ name: 'John', age: 30 });\nsetState(prevState => ({ ...prevState, age: 31 }));\n```\nThis ensures that React detects the state change and triggers a re-render."
        },
        {
            "question": "How do you update nested objects inside state?",
            "answer": "Updating nested objects in state requires you to update the nested properties without directly mutating the original state. You can use the **spread operator** and nested updates to ensure immutability.\n\nExample:\n\n1. Access the state using the `useState` hook.\n2. Use the spread operator to copy the outer object.\n3. For nested objects, use the spread operator again to copy the nested object and update the desired properties.\n4. Set the updated state using the state setter function.\n\nExample code:\n\n```javascript\nconst [state, setState] = useState({ user: { name: 'John', age: 30 }, city: 'New York' });\nsetState(prevState => ({\n  ...prevState,\n  user: { ...prevState.user, age: 31 }\n}));\n```\nThis pattern ensures that React can detect the changes and re-render accordingly."
        },
        {
            "question": "How to perform automatic redirect after login?",
            "answer": "To perform an automatic redirect after login in React, you can use React Router's useHistory or useNavigate (in React Router v6) hook. After the user successfully logs in, you can use the history.push() or navigate() method to redirect the user to another page. Here's how to do it:\n\n1) In React Router v5 (useHistory):\n\n- Import the `useHistory` hook.\n- After successful login, use `history.push('/destination')` to redirect the user.\n\nExample:\n\n```\nimport { useHistory } from 'react-router-dom';\n\nconst Login = () => {\n  const history = useHistory();\n\n  const handleLogin = () => {\n    // Perform login logic\n    history.push('/dashboard'); // Redirect after login\n  };\n\n  return <button onClick={handleLogin}>Login</button>;\n};\n```\n\n2) In React Router v6 (useNavigate):\n\n- Import the `useNavigate` hook.\n- After successful login, use `navigate('/destination')`.\n\nExample:\n\n```\nimport { useNavigate } from 'react-router-dom';\n\nconst Login = () => {\n  const navigate = useNavigate();\n\n  const handleLogin = () => {\n    // Perform login logic\n    navigate('/dashboard'); // Redirect after login\n  };\n\n  return <button onClick={handleLogin}>Login</button>;\n};\n```\n\nThis will automatically redirect the user after they log in successfully."
        },
        {
            "question": "How to apply validation on props in React?",
            "answer": "Validation on props in React is done using the PropTypes library. PropTypes allows you to define the expected data types and requirements for each prop passed to a component. If a prop does not match the expected type or is missing (when required), React will log a warning in the console during development. To use PropTypes, import the library, and define the propTypes object in your component, specifying the type and whether the prop is required."
        },
        {
            "question": "How do you update arrays inside state?",
            "answer": "To update arrays inside state, you should not directly mutate the array. Instead, use methods that return new arrays, like **map**, **filter**, **concat**, or the **spread operator**.\n\nExample:\n\n1. Access the state using the `useState` hook.\n2. Use the spread operator to create a new array and update the elements as needed.\n3. Set the new array as the updated state.\n\nExample code:\n\n```javascript\nconst [items, setItems] = useState([1, 2, 3]);\nsetItems(prevItems => [...prevItems, 4]);\n```\nFor more complex updates, you can use **map** to update individual elements, or **filter** to remove items. It's important to always return a new array to maintain immutability and allow React to track the changes."
        },
        {
            "question": "What are the benefits of preventing the direct state mutations?",
            "answer": "Preventing direct state mutations in React offers several benefits:\n\n1. **Predictable State**: By avoiding direct mutations, the state becomes more predictable, as changes to the state are explicitly managed, making debugging easier.\n2. **Efficient Re-rendering**: React relies on detecting state changes by comparing previous and current states. Direct mutation can bypass this, leading to potential bugs or unnecessary re-renders.\n3. **Immutability Benefits**: Immutable state changes allow you to track previous states, enabling features like undo/redo or time-travel debugging.\n4. **Component Reusability**: By maintaining an immutable state, components are less dependent on side effects and can be reused in different parts of the application without introducing unexpected behavior."
        },
        {
            "question": "What are the preferred and non-preferred array operations for updating the state?",
            "answer": "In React, when updating the state that involves arrays, it's important to use operations that do not mutate the original state. Here are some preferred and non-preferred operations:\n\n**Preferred Operations (Immutable Operations):**\n1. **map()**: Used to transform items in an array, returning a new array.\n2. **filter()**: Used to remove items from an array, returning a new array with only the items that match the condition.\n3. **concat()**: Used to add items to an array without modifying the original array.\n4. **spread operator (`...`)**: Used to copy elements of an array into a new array (e.g., `[...stateArray, newItem]`).\n\n**Non-preferred Operations (Mutative Operations):**\n1. **push()**: Modifies the original array by adding an item.\n2. **pop()**: Removes the last item from the array, modifying the array in place.\n3. **shift()**: Removes the first item from the array, mutating the array.\n4. **splice()**: Modifies the array by adding or removing items at specific indexes.\n\nFor optimal React state management, always use immutable operations like `map`, `filter`, `concat`, and the spread operator to ensure proper state updates and efficient re-rendering."
        },
        {
            "question": "How to send data from child to parent using callback functions?",
            "answer": "To send data from a child component to a parent component using callback functions in React:\n\n1. **Define a callback function in the parent component**: The parent component will define a function that will handle the data sent from the child.\n2. **Pass the callback function as a prop to the child**: The parent passes this function to the child component as a prop.\n3. **Invoke the callback function in the child**: Inside the child component, when a certain event occurs (like a button click or input change), the child calls the callback function passed from the parent and passes the data as arguments.\n\nThis approach allows the parent to receive data from the child and perform actions based on that data. The child is responsible for invoking the callback, while the parent manages the state or logic.\n\nExample: \n- Parent Component: Defines a function and passes it as a prop to the child.\n- Child Component: Calls the function with the required data when necessary."
        },
        {
            "question": "What are fragments in React, and why would you use them?",
            "answer": "Fragments in React are a lightweight way to return multiple elements from a component without adding extra nodes to the DOM. The `React.Fragment` component allows you to group a list of children without introducing a parent wrapper element. This is useful for reducing unnecessary markup and maintaining a cleaner DOM."
        },
        {
            "question": "Why fragments are better than container divs?",
            "answer": "Fragments are better than container divs because they allow you to group a list of children without adding extra nodes to the DOM. This is beneficial for performance optimization and avoids unnecessary wrapping elements, which can interfere with styling or layout."
        },
        {
            "question": "What are the limitations of React?",
            "answer": "The limitations of React include the following: 1) React has a steep learning curve for beginners, especially with concepts like JSX, virtual DOM, and hooks. 2) It is only a library for UI development, so developers need to rely on additional libraries or frameworks for routing, state management, and other features. 3) React applications may experience performance issues in very large apps if not optimized properly. 4) Frequent updates and changes in the ecosystem can make it challenging to keep up with best practices. 5) Overhead in setup for small-scale projects, as it requires tooling like Webpack or Babel."
        },
        {
            "question": "What are the advantages of React over Vue.js?",
            "answer": "React has the following advantages over Vue.js: \n\n1. Gives more flexibility in developing large apps.\n2. Easier to test.\n3. Suitable for creating mobile apps.\n4. More information and solutions available due to its larger community and ecosystem."
        },
        {
            "question": "Why React tab is not showing up in DevTools?",
            "answer": "When the page loads, React DevTools sets a global named __REACT_DEVTOOLS_GLOBAL_HOOK__, then React communicates with that hook during initialization. If the website is not using React or if React fails to communicate with DevTools, then it won't show up the tab."
        },
        {
            "question": "What are Styled Components?",
            "answer": "styled-components is a JavaScript library for styling React applications. It removes the mapping between styles and components, and lets you write actual CSS augmented with JavaScript."
        },
        {
            "question": "What is Relay?",
            "answer": "Relay is a JavaScript framework for providing a data layer and client-server communication to web applications using the React view layer."
        },
        {
            "question": "What are the main features of Reselect library?",
            "answer": "Let's see the main features of Reselect library:\n\n1. Selectors can compute derived data, allowing Redux to store the minimal possible state.\n2. Selectors are efficient. A selector is not recomputed unless one of its arguments changes.\n3. Selectors are composable. They can be used as input to other selectors."
        },
        {
            "question": "What is the behavior of uncaught errors in react 16?",
            "answer": "In React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree. The reason behind this decision is that it is worse to leave corrupted UI in place than to completely remove it. For example, it is worse for a payments app to display a wrong amount than to render nothing."
        },
        {
            "question": "Does React support all HTML attributes?",
            "answer": "As of React 16, both standard or custom DOM attributes are fully supported. Since React components often take both custom and DOM-related props, React uses the camelCase convention just like the DOM APIs."
        },
        {
            "question": "What is the browser support for react applications?",
            "answer": "React supports all popular browsers, including Internet Explorer 9 and above, although some polyfills are required for older browsers such as IE 9 and IE 10. If you use es5-shim and es5-sham polyfill then it even support old browsers that doesn't support ES5 methods."
        }
    ],
    "redux": [
        {
            "question": "What is Redux, and how does it relate to React?",
            "answer": "Redux is a state management library often used with React. It provides a predictable state container by centralizing the application state, allowing components to access and update state through actions and reducers."
        },
        {
            "question": "What is Flux?",
            "answer": "Flux is an application design paradigm used as a replacement for the more traditional MVC (Model-View-Controller) pattern. It is not a framework or a library but rather an architecture pattern that complements React. Flux is centered around the concept of Unidirectional Data Flow, where the data flows in one direction, making it easier to manage application state. This pattern is used by Facebook internally when working with React."
        },
        {
            "question": "What is Redux?",
            "answer": "Redux is a predictable state container for JavaScript applications, inspired by the Flux design pattern. It allows for central management of the application's state, making it easier to predict how data changes over time. Redux can be used with React or any other view library. It is lightweight (about 2kB) and has no dependencies, focusing on simplicity and scalability."
        },
        {
            "question": "What are the core principles of Redux?",
            "answer": "The core principles of Redux are: Single Source of Truth, where the entire state of the application is stored in a single, immutable state tree; State is Read-Only, ensuring changes occur only through actions; and Changes are Made with Pure Reducers, which are pure functions determining state updates."
        },
        {
            "question": "What are pure functions and side effects in the context of Redux?",
            "answer": "In Redux, pure functions are functions that always produce the same output for the same input and do not modify external state. Side effects refer to operations like API calls, logging, or updating external systems, which should be handled outside of reducers, typically in middleware like Redux Thunk."
        },
        {
            "question": "What is meant by 'immutable state,' and why is it important in Redux?",
            "answer": "Immutable state means the state cannot be modified directly; instead, new state objects are created for updates. This ensures predictable state management, facilitates debugging, and supports features like time-travel debugging in Redux."
        },
        {
            "question": "Can you describe the concept of 'single source of truth' in Redux?",
            "answer": "In Redux, the 'single source of truth' means that the entire application state is stored in a single, centralized store, making it predictable and ensuring consistency across the app."
        },
        {
            "question": "What are the downsides of Redux compared to Flux?",
            "answer": "Instead of calling them downsides, we can refer to these as compromises when using Redux over Flux:\n\n1. **Avoiding mutations**: Redux is very opinionated about immutability, whereas Flux allows mutations. Redux doesn't like mutations, and it often requires the use of tools like `redux-immutable-state-invariant`, `Immutable.js`, or strict coding guidelines to ensure non-mutating code.\n2. **Choosing packages carefully**: Redux has extension points like middleware and store enhancers, which makes it flexible. However, unlike Flux, which doesn't address certain concerns like undo/redo or form handling, Redux's ecosystem requires developers to carefully select packages for such features.\n3. **Lack of flow integration**: While Flux has good static type checking support, Redux doesn't have robust Flow integration yet, making type safety more challenging."
        },
        {
            "question": "Can I dispatch an action in reducer?",
            "answer": "Dispatching an action within a reducer is considered an anti-pattern. Reducers should be pure functions without side effects. Their only purpose is to process the action payload and return a new state object. Adding listeners or dispatching actions within a reducer can lead to chained actions and unpredictable side effects, making the state management harder to reason about."
        },
        {
            "question": "What are the drawbacks of MVW pattern?",
            "answer": "The drawbacks of the Model-View-Whatever (MVW) pattern include: \n1. DOM manipulation is expensive, leading to slower and less efficient applications. \n2. Circular dependencies can complicate the relationship between models and views. \n3. Frequent data changes, especially in collaborative applications (e.g., Google Docs), can lead to performance issues. \n4. Implementing undo functionality (or 'travel back in time') can be difficult and require a significant amount of extra code."
        },
        {
            "question": "Are there any similarities between Redux and RxJS?",
            "answer": "Redux and RxJS are very different tools with distinct purposes, but they share some vague similarities. \n1. Redux is a state management tool commonly used for managing application state and UI architecture, whereas RxJS is a reactive programming library typically used for handling asynchronous tasks. \n2. Both use the reactive paradigm: Redux reacts to actions and updates the store, while RxJS provides Observables to manage streams of data. \n3. While Redux focuses on application state management, RxJS provides foundational tools (Observables) to work with streams, which can be used in various contexts, including state management."
        },
        {
            "question": "How to reset state in Redux?",
            "answer": "You need to write a root reducer in your application which delegate handling the action to the reducer generated by combineReducers()."
        },
        {
            "question": "Explain the significance of the combineReducers function.",
            "answer": "The combineReducers function is used to organize and manage multiple reducers by combining them into a single root reducer, allowing better modularity and maintainability of the Redux state."
        },
        {
            "question": "Should I keep all component's state in Redux store?",
            "answer": "Keep your data in the Redux store, and the UI related state internally in the component."
        },
        {
            "question": "What is the difference between React context and React Redux?",
            "answer": "React Context is great for passing data to deeply nested components, and it's simple to use directly within your application. It's best for smaller applications or when state doesn't need complex handling. React Redux, on the other hand, provides a powerful set of features for global state management, including middleware, time-travel debugging, and more advanced state transformations. Redux uses React Context internally but offers a much more structured and feature-rich solution."
        },
        {
            "question": "What is a reducer in Redux and what role does it play?",
            "answer": "A reducer in Redux is a pure function responsible for managing specific parts of your application state. It captures state changes and computes the new state based on those changes."
        },
        {
            "question": "Why are Redux state functions called reducers?",
            "answer": "Reducers are called so because they accumulate the state based on previous actions, essentially reducing it to a new state. Each time a reducer is called, it takes the current state and action as parameters and returns the next state, transforming the data. This process is like reducing a collection of actions to a final state."
        },
        {
            "question": "What is the proper way to access Redux store?",
            "answer": "The best way to access the Redux store in a component is by using the `connect()` function, which creates a new component wrapping your existing one. This higher-order component maps state and action creators to the component’s props, allowing the component to automatically re-render when the store updates."
        },
        {
            "question": "What is the difference between component and container in React Redux?",
            "answer": "A component is a presentational part of your application, often a stateless function or class. A container, on the other hand, is a component connected to the Redux store. Containers are responsible for subscribing to state updates and dispatching actions, while delegating the rendering to presentational components."
        },
        {
            "question": "What is the purpose of the constants in Redux?",
            "answer": "Constants in Redux are used to avoid bugs caused by typos in action types. By defining constants for each action type, you can easily find and manage them throughout the project, especially in large applications. Constants improve maintainability and reduce the chances of runtime errors."
        },
        {
            "question": "How to structure Redux top level directories?",
            "answer": "In a typical Redux project, directories are often structured as follows: `Components` for dumb components, `Containers` for smart components connected to Redux, `Actions` for action creators, `Reducers` for reducers, and `Store` for store initialization. This structure is well-suited for small to medium-sized applications."
        },
        {
            "question": "What is redux-saga?",
            "answer": "redux-saga is a library used to handle side effects (like asynchronous operations or impure functions such as API calls) in React/Redux applications. It provides a more manageable and testable way to deal with complex side effects and is installed via npm: `$ npm install --save redux-saga`."
        },
        {
            "question": "How do you handle asynchronous actions in Redux?",
            "answer": "Asynchronous actions in Redux are typically handled using middleware like Redux Thunk or Redux Saga, which allows action creators to dispatch actions asynchronously, such as fetching data from an API, before dispatching final actions to update the state."
        },
        {
            "question": "What is the mental model of redux-saga?",
            "answer": "redux-saga is like a separate thread dedicated to handling side effects in your application. It acts as a Redux middleware that can start, pause, or cancel side effects based on normal Redux actions. It has full access to the Redux application state and can dispatch Redux actions itself."
        },
        {
            "question": "What are the differences between call() and put() in redux-saga?",
            "answer": "Both `call()` and `put()` are effect creators in redux-saga. `call()` is used to describe an effect to invoke a function or promise, while `put()` is used to describe an effect that dispatches an action to the Redux store. They both instruct the middleware on what to do but in different ways."
        },
        {
            "question": "What is Redux Thunk?",
            "answer": "Redux Thunk is a middleware that allows action creators to return a function instead of a plain action object. This function receives the `dispatch()` and `getState()` methods as arguments and can be used to delay the dispatch or dispatch actions conditionally based on the current state."
        },
        {
            "question": "What are the differences between redux-saga and redux-thunk?",
            "answer": "Redux Thunk and Redux Saga both handle side effects, but they do so in different ways. Thunk uses Promises and is simpler to use, while Redux Saga uses Generators, which are more powerful but require learning. Both can coexist, so you can start with Thunks and switch to Sagas if your app's needs grow."
        },
        {
            "question": "What is Redux DevTools?",
            "answer": "Redux DevTools is a powerful tool for live-editing, time travel debugging, and inspecting Redux state changes. It provides features like hot reloading, action replay, and a customizable UI. For easier integration, you can use the Redux DevTools Extension for Chrome or Firefox, which allows you to view and manage Redux state without manual setup."
        },
        {
            "question": "What are the features of Redux DevTools?",
            "answer": "Redux DevTools features include time-travel debugging, state change inspection, action replay, performance monitoring, and integration with browser extensions for enhanced debugging and development workflow."
        },
        {
            "question": "What is Redux Form?",
            "answer": "Redux Form works with React and Redux to enable a form in React to use Redux to store all of its state. Redux Form can be used with raw HTML5 inputs, but it also works very well with common UI frameworks like Material UI, React Widgets, and React Bootstrap."
        },
        {
            "question": "How does Redux differ from local component state in React?",
            "answer": "Redux provides a centralized state management system that enables sharing state across the entire application, while local component state is isolated to specific components. Redux is ideal for managing global state and complex state interactions, whereas local state is suited for component-specific data and transient UI states."
        },
        {
            "question": "What are the main features of Redux Form?",
            "answer": "The main features of Redux Form include tracking field state in Redux, supporting synchronous and asynchronous validation, providing reusable form components, ensuring state immutability, and enabling easy integration with the Redux store for centralized form state management."
        },
        {
            "question": "How Relay is different from Redux?",
            "answer": "Relay is similar to Redux in that they both use a single store. The main difference is that Relay only manages state originated from the server, and all access to the state is done via GraphQL queries (for reading data) and mutations (for changing data). Relay caches the data for you and optimizes data fetching by fetching only changed data and nothing more."
        },
        {
            "question": "What is the difference between React Native and React?",
            "answer": "React is a JavaScript library, supporting both front-end web development and server-side rendering, for building user interfaces and web applications. React Native, on the other hand, is a mobile framework that compiles to native app components, allowing you to build native mobile applications (iOS, Android, and Windows) in JavaScript. React Native allows you to use React to build your components and implements React under the hood."
        },
        {
            "question": "How to test React Native apps?",
            "answer": "React Native apps can be tested in mobile simulators like iOS and Android. Additionally, you can run the app on your mobile device using the Expo app (https://expo.io). To sync, you need to scan the QR code provided by Expo, and both your mobile device and computer should be on the same wireless network."
        },
        {
            "question": "How to do logging in React Native?",
            "answer": "In React Native, you can use console.log, console.warn, and other console methods for logging. For logs specific to iOS or Android, you can run the following commands in the terminal:\n\n$ react-native log-ios\n$ react-native log-android"
        },
        {
            "question": "How to debug your React Native?",
            "answer": "To debug a React Native app, follow these steps:\n\n1. Run your application in the iOS simulator.\n2. Press Command + D to open the developer menu and a webpage should open at http://localhost:8081/debugger-ui.\n3. Enable 'Pause On Caught Exceptions' for a better debugging experience.\n4. Press Command + Option + I to open the Chrome Developer Tools, or open it via View -> Developer -> Developer Tools.\n5. You should now be able to debug as you normally would."
        },
        {
            "question": "What is reselect and how it works?",
            "answer": "Reselect is a selector library for Redux that uses memoization. It was originally designed to compute derived data from a Redux-like application's state but can be used with any architecture. Reselect keeps a copy of the last inputs and outputs and recomputes the result only when an input changes. If the same inputs are provided again, Reselect returns the cached output. Its memoization and cache are fully customizable."
        },
        {
            "question": "What is a 'selector' in Redux and what is its purpose?",
            "answer": "A selector in Redux is a function used to extract and derive specific data from the Redux store, improving code readability and reusability by centralizing state selection logic."
        },
        {
            "question": "What is Flow?",
            "answer": "Flow is a static type checker designed to find type errors in JavaScript. Flow types allow for fine-grained distinctions and help catch errors, such as those involving null, that other type systems might miss."
        },
        {
            "question": "What is the difference between Flow and PropTypes?",
            "answer": "Flow is a static analysis tool that uses a superset of the language to add type annotations and catch errors at compile time. PropTypes is a runtime type checker specific to React components, checking only the types of props passed to a component. For more flexible type checking across an entire project, Flow or TypeScript is preferred over PropTypes."
        },
        {
            "question": "What is React Dev Tools?",
            "answer": "React Developer Tools let you inspect the component hierarchy, including component props and state. It is available as a browser extension (for Chrome and Firefox) and as a standalone app (compatible with other environments such as Safari, IE, and React Native). The official extensions are available for Chrome, Firefox, and as a standalone app for other environments like Safari and React Native."
        },
        {
            "question": "Why is DevTools not loading in Chrome for local files?",
            "answer": "If you opened a local HTML file in your browser (file://...), you need to go to Chrome Extensions and check 'Allow access to file URLs' to ensure that React DevTools can load properly."
        },
        {
            "question": "Can Redux only be used with React?",
            "answer": "Redux can be used as a data store for any UI layer. The most common usage is with React and React Native, but there are bindings available for Angular, Angular 2, Vue, Mithril, and more. Redux simply provides a subscription mechanism which can be used by any other code."
        },
        {
            "question": "How does Redux handle the flow of data and actions?",
            "answer": "Redux handles data flow in a unidirectional manner: actions are dispatched to describe state changes, reducers process these actions to update the state, and the store notifies subscribed components to re-render with the updated state."
        },
        {
            "question": "Do you need to have a particular build tool to use Redux?",
            "answer": "Redux is originally written in ES6 and transpiled for production into ES5 with Webpack and Babel. You should be able to use it regardless of your JavaScript build process. Redux also offers a UMD build that can be used directly without any build process at all."
        }
    ],
    "categories": [
        {
            "name": "React",
            "id": "1"
        },
        {
            "name": "Redux",
            "id": "2"
        },
        {
            "name": "React native",
            "id": "3"
        },
        {
            "name": "Angular",
            "id": "4"
        },
        {
            "name": "Next.js",
            "id": "5"
        },
        {
            "name": "Javascript",
            "id": "6"
        },
        {
            "name": "Html",
            "id": "7"
        },
        {
            "name": "Css",
            "id": "8"
        },
        {
            "name": "flutter",
            "id": "9"
        }
    ]
}